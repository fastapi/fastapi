import sys
from typing import Any, ClassVar, Generic, TypeVar

from _ctypes import (
    POINTER as POINTER,
)
from _ctypes import (
    RTLD_GLOBAL as RTLD_GLOBAL,
)
from _ctypes import (
    RTLD_LOCAL as RTLD_LOCAL,
)
from _ctypes import (
    ArgumentError as ArgumentError,
)
from _ctypes import (
    Array as Array,
)
from _ctypes import (
    CFuncPtr as _CFuncPtr,
)
from _ctypes import (
    Structure as Structure,
)
from _ctypes import (
    Union as Union,
)
from _ctypes import (
    _CanCastTo as _CanCastTo,
)
from _ctypes import (
    _CArgObject as _CArgObject,
)
from _ctypes import (
    _CData as _CData,
)
from _ctypes import (
    _CDataMeta as _CDataMeta,
)
from _ctypes import (
    _CField as _CField,
)
from _ctypes import (
    _Pointer as _Pointer,
)
from _ctypes import (
    _PointerLike as _PointerLike,
)
from _ctypes import (
    _SimpleCData as _SimpleCData,
)
from _ctypes import (
    _StructUnionBase as _StructUnionBase,
)
from _ctypes import (
    _StructUnionMeta as _StructUnionMeta,
)
from _ctypes import (
    addressof as addressof,
)
from _ctypes import (
    alignment as alignment,
)
from _ctypes import (
    byref as byref,
)
from _ctypes import (
    get_errno as get_errno,
)
from _ctypes import (
    pointer as pointer,
)
from _ctypes import (
    resize as resize,
)
from _ctypes import (
    set_errno as set_errno,
)
from _ctypes import (
    sizeof as sizeof,
)
from typing_extensions import TypeAlias

if sys.platform == "win32":
    from _ctypes import FormatError as FormatError
    from _ctypes import get_last_error as get_last_error
    from _ctypes import set_last_error as set_last_error

if sys.version_info >= (3, 9):
    from types import GenericAlias

_T = TypeVar("_T")
_DLLT = TypeVar("_DLLT", bound=CDLL)

DEFAULT_MODE: int

class CDLL:
    _func_flags_: ClassVar[int]
    _func_restype_: ClassVar[_CData]
    _name: str
    _handle: int
    _FuncPtr: type[_FuncPointer]
    if sys.version_info >= (3, 8):
        def __init__(
            self,
            name: str | None,
            mode: int = ...,
            handle: int | None = None,
            use_errno: bool = False,
            use_last_error: bool = False,
            winmode: int | None = None,
        ) -> None: ...
    else:
        def __init__(
            self,
            name: str | None,
            mode: int = ...,
            handle: int | None = None,
            use_errno: bool = False,
            use_last_error: bool = False,
        ) -> None: ...

    def __getattr__(self, name: str) -> _NamedFuncPointer: ...
    def __getitem__(self, name_or_ordinal: str) -> _NamedFuncPointer: ...

if sys.platform == "win32":
    class OleDLL(CDLL): ...
    class WinDLL(CDLL): ...

class PyDLL(CDLL): ...

class LibraryLoader(Generic[_DLLT]):
    def __init__(self, dlltype: type[_DLLT]) -> None: ...
    def __getattr__(self, name: str) -> _DLLT: ...
    def __getitem__(self, name: str) -> _DLLT: ...
    def LoadLibrary(self, name: str) -> _DLLT: ...
    if sys.version_info >= (3, 9):
        def __class_getitem__(cls, item: Any) -> GenericAlias: ...

cdll: LibraryLoader[CDLL]
if sys.platform == "win32":
    windll: LibraryLoader[WinDLL]
    oledll: LibraryLoader[OleDLL]
pydll: LibraryLoader[PyDLL]
pythonapi: PyDLL

class _FuncPointer(_CFuncPtr): ...

class _NamedFuncPointer(_FuncPointer):
    __name__: str

def CFUNCTYPE(
    restype: type[_CData] | None,
    *argtypes: type[_CData],
    use_errno: bool = ...,
    use_last_error: bool = ...,
) -> type[_FuncPointer]: ...

if sys.platform == "win32":
    def WINFUNCTYPE(
        restype: type[_CData] | None,
        *argtypes: type[_CData],
        use_errno: bool = ...,
        use_last_error: bool = ...,
    ) -> type[_FuncPointer]: ...

def PYFUNCTYPE(
    restype: type[_CData] | None, *argtypes: type[_CData]
) -> type[_FuncPointer]: ...

# Any type that can be implicitly converted to c_void_p when passed as a C function argument.
# (bytes is not included here, see below.)
_CVoidPLike: TypeAlias = _PointerLike | Array[Any] | _CArgObject | int
# Same as above, but including types known to be read-only (i. e. bytes).
# This distinction is not strictly necessary (ctypes doesn't differentiate between const
# and non-const pointers), but it catches errors like memmove(b'foo', buf, 4)
# when memmove(buf, b'foo', 4) was intended.
_CVoidConstPLike: TypeAlias = _CVoidPLike | bytes

_CastT = TypeVar("_CastT", bound=_CanCastTo)

def cast(obj: _CData | _CArgObject | int, typ: type[_CastT]) -> _CastT: ...
def create_string_buffer(
    init: int | bytes, size: int | None = None
) -> Array[c_char]: ...

c_buffer = create_string_buffer

def create_unicode_buffer(
    init: int | str, size: int | None = None
) -> Array[c_wchar]: ...

if sys.platform == "win32":
    def DllCanUnloadNow() -> int: ...
    def DllGetClassObject(
        rclsid: Any, riid: Any, ppv: Any
    ) -> int: ...  # TODO not documented
    def GetLastError() -> int: ...

def memmove(dst: _CVoidPLike, src: _CVoidConstPLike, count: int) -> int: ...
def memset(dst: _CVoidPLike, c: int, count: int) -> int: ...
def string_at(address: _CVoidConstPLike, size: int = -1) -> bytes: ...

if sys.platform == "win32":
    def WinError(code: int | None = None, descr: str | None = None) -> OSError: ...

def wstring_at(address: _CVoidConstPLike, size: int = -1) -> str: ...

class c_byte(_SimpleCData[int]): ...

class c_char(_SimpleCData[bytes]):
    def __init__(self, value: int | bytes | bytearray = ...) -> None: ...

class c_char_p(_PointerLike, _SimpleCData[bytes | None]):
    def __init__(self, value: int | bytes | None = ...) -> None: ...

class c_double(_SimpleCData[float]): ...
class c_longdouble(_SimpleCData[float]): ...
class c_float(_SimpleCData[float]): ...
class c_int(_SimpleCData[int]): ...
class c_int8(_SimpleCData[int]): ...
class c_int16(_SimpleCData[int]): ...
class c_int32(_SimpleCData[int]): ...
class c_int64(_SimpleCData[int]): ...
class c_long(_SimpleCData[int]): ...
class c_longlong(_SimpleCData[int]): ...
class c_short(_SimpleCData[int]): ...
class c_size_t(_SimpleCData[int]): ...
class c_ssize_t(_SimpleCData[int]): ...
class c_ubyte(_SimpleCData[int]): ...
class c_uint(_SimpleCData[int]): ...
class c_uint8(_SimpleCData[int]): ...
class c_uint16(_SimpleCData[int]): ...
class c_uint32(_SimpleCData[int]): ...
class c_uint64(_SimpleCData[int]): ...
class c_ulong(_SimpleCData[int]): ...
class c_ulonglong(_SimpleCData[int]): ...
class c_ushort(_SimpleCData[int]): ...
class c_void_p(_PointerLike, _SimpleCData[int | None]): ...
class c_wchar(_SimpleCData[str]): ...

class c_wchar_p(_PointerLike, _SimpleCData[str | None]):
    def __init__(self, value: int | str | None = ...) -> None: ...

class c_bool(_SimpleCData[bool]):
    def __init__(self, value: bool = ...) -> None: ...

if sys.platform == "win32":
    class HRESULT(_SimpleCData[int]): ...  # TODO undocumented

class py_object(_CanCastTo, _SimpleCData[_T]): ...
class BigEndianStructure(Structure): ...
class LittleEndianStructure(Structure): ...
