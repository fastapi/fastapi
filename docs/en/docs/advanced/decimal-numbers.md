# Decimal Numbers

!!! warning
    This is a rather advanced feature. You probably can skip it.

    If you are just following the tutorial - user guide, you can probably skip this section.

    If you already know that you need to modify the generated OpenAPI schema, continue reading.

In cases where precision is important, such as **finances**,  **science research**, the default `flaot` type is not punctual enough in most cases.

```Python
>>> 1.1 + 2.2
3.3000000000000003
```

That's where `Decimal` comes in to play:

```Python
>>> from decimal import Decimal
>>> Decimal("1.1") + Decimal("2.2")
Decimal('3.3')
```

Before you start playing around with decimal in FastAPI application, the most important thing is to make sure that each dependencies and components you're using had the capabilites of hadling decimal (or sometimes call numeric) data type. That includes dependencies (such as [Pydantic](https://pydantic-docs.helpmanual.io/usage/types/#arguments-to-condecimal)), or database.

In the following discussion, we'll use this example to discuss some possibility on how to serialize decimal:

```Python hl_lines="1  15  16"
{!../../../docs_src/decimal_numbers/default_serialize.py!}
```

## `float` Capped Serialization (Default)

If you run the above example as is, you'll get a response like this:

```json
{"pi":3.141592653589793,"e":2.718281828459045}
```

You'll noticed that, despite we provided 35 decimal points for `pi` and `e` respectively. When encoded with the native JSON encoder and serializer, the `Decimal` type will be converted implicitly to `float`.

## `str` Serialization

When you can not assured that client had the same capability to handle decimal data, the simplest solution would be simply passing decimal data as `str`, as string don't get randomly trimmed.

To achieve that, we'll use the method described in [Pydantic's `json_encoders`](https://pydantic-docs.helpmanual.io/usage/exporting_models/#json_encoders). Namely, by passing this additional `dict`, we're telling pydantic to return `str(d)` when there is a field value `d` with `Decimal` type.

```Python hl_lines="11  12"
{!../../../docs_src/decimal_numbers/str_serialize.py!}
```

In which you'll get decimal uncapped:

```json
{"pi":"3.14159265358979323846264338327950288","e":"2.71828182845904523536028747135266249"}
```

## `float` Uncapped Serialization (Use `SimpleJSONResponse`)

If you're sure that your client is capable of handling long-decimal-points number, whether is float, double, numeric or any kind, and you don't feel passing `str` is your thing. The `SimpleJSONResponse` using <a href="https://github.com/simplejson/simplejson" class="external-link" target="_blank">`simplejson`</a> under the hood is what you're looking for.

```Python hl_lines="4  12  13  24"
{!../../../docs_src/decimal_numbers/float_serialize.py!}
```

and voil√†:

```json
{"pi":3.14159265358979323846264338327950288,"e":2.71828182845904523536028747135266249}
```

!!! warning
    If you're testing this script in interactive UI (Swagger UI, or ReDoc), you might still find the decimal points being capped of. That's because native JavaScript happens to be one of the client which we've just mentioned, not able to handling long-decimal-points number. You'll have to visit <a href="http://127.0.0.1:8000" class="external-link" target="_blank">http://127.0.0.1:8000</a> directly to see proper response output.

Looking at this example, you might be wondering why is it necessary to use both `json_encoders` and `response_class`? Well, this is because FastAPI and Pydantic had there own mechanism of making a data in to JSON string, in the following order:

1. Data is reutrned from the routing function (in this case, `num_model`)
2. The data will be fit into `response_model` (in this case, `IrrationalNumbers`)
3. FastAPI will convert this fitted data to json-encodable `dict` by calling `num_model.dict()`. Notice that we're not generating json string yet. We're just preparing the data, to make sure every key and value inside the dict is composed of primative type (`int`, `str`, ...etc). This is also the place where pydantic's `json_encoders` plays its roles
4. The final JSON string is then generated by passing `num_model` to `SimpleJSONResponse`

The key point here is that despite `SimpleJSONResponse` is capable of encoding `Decimal` type, you must assign `json_encoders` on model definition, otherwise pydantic will cast the `Decimal` to `float` prior to that.

!!! tip
    If you're using `SimpleJSONResponse` application wide, you can make use of the `default_response_class` when instantiated the `app`.

## Conclusion and Recap

Despite FastAPI is flexible enough to achieve most what you'd want it to behave, the key takeaway here is that you should always evaluate your specific scnario and adapt to proper method.

Maybe you only need two decimal points, and times/divided by 100 isn't something too bad.

Maybe your client (Frontend website, mobile app) is not supported, then why bother implement this?

Anyway, in this page, we've demonstrate two key points to help integrated Decimal support to your FastAPI application:

* `json_encoders` parameters in pydantic model
* `SimpleJSONResponse` to serialize Decimal JSON
