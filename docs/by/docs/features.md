# Асаблівасці

## Асаблівасці FastAPI

**FastAPI** дае Вам наступнае:

### Грунтуецца на адкрытых стандартах

* <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank"><strong>OpenAPI</strong></a> для стварэння API, у тым ліку дэкларацыі аперацый шляху, параметраў, запытаў цела, бяспекі і г.д.
* Аўтаматычная дакументацыя мадэлі даных з выкарыстаннем <a href="https://json-schema.org/" class="external-link" target="_blank"><strong>JSON Schema</strong></a> (таму што OpenAPI заснаваны на JSON Schema).
* Распрацаваны вакол гэтых стандартаў пасля іх дасканалага вывучэння, а не як дадатковая надбудова над імі.
* Гэта таксама дазваляе выкарыстоўваць аўтаматычную **генерацыю кліенцкага кода** на многіх мовах.

### Аўтаматычная дакументацыя

Інтэрактыўная дакументацыя па API і вэб-інтэрфейс для даследавання карыстальніцкіх інтэрфейсаў. Паколькі фреймворк заснаваны на OpenAPI, ёсць некалькі варыянтаў, 2 з якіх уключаны па змаўчанні.

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank"><strong>Swagger UI</strong></a> - інтэрактыўнае даследаванне, выклік і тэставанне вашага API непасрэдна з браўзера.

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank"><strong>ReDoc</strong></a> - альтэрнатыўная дакументацыя API.

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Выключна сучасны Python

Усё заснавана на стандартных **анатацыях тыпаў Python 3.6** (дзякуючы Pydantic). Не трэба вывучаць новы сінтаксіс. Проста стандартны сучасны Python.

Калі вам трэба ўзгадаць, як выкарыстоўваць тыпы Python (нават калі вы не выкарыстоўваеце FastAPI), вылучыце 2 хвіліны і азнаёмцеся з кароткім кіраўніцтвам: [Python Types](python-types.md){.internal-link target=_blank}.

Вы пішаце на стандартным Python з анатацыямі тыпаў:

```Python
from datetime import date

from pydantic import BaseModel

# Аб'явіце пераменную як str
# і атрымайце падтрымку рэдактара ўнутры функцыі
def main(user_id: str):
    return user_id


# A Pydantic model
class User(BaseModel):
    id: int
    name: str
    joined: date
```

Гэта можа быць выкарыстана наступным чынам:

```Python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```

!!! Інфармацыя
    `**second_user_data` азначае:

    Перадайце ключы і значэнні слоўніка second_user_data непасрэдна ў якасці аргументаў ключ-значэнне, эквівалентна: `User(id=4, name="Mary", joined="2018-11-30")`

### Падтрымка рэдактараў

Увесь фрэймворк быў распрацаваны так, каб быць простым і інтуітыўна зразумелым у выкарыстанні, усе рашэнні былі правераны ў некалькіх рэдактарах яшчэ да пачатку стварэння, каб забяспечыць найлепшае уздзеянне на распрацоўку.

У апошнім апытанні Python-распрацоўшчыкаў было відавочна, <a href="https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features" class="external-link" target="_blank">што найбольш часта выкарыстоўванай функцыяй з'яўляецца "аўтадапаўненне"</a>.

Увесь фрэймворк **FastAPI** задавальняе гэтаму. Аўтадапаўненне працуе ўсюды.

Вам рэдка трэба будзе вяртацца да дакументацыі.

Вось як вам можа дапамагчы ваш рэдактар:

* <a href="https://code.visualstudio.com/" class="external-link" target="_blank">Visual Studio Code</a>:

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

* <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a>:

![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)

Вы атрымаеце дапаўненне ў кодзе, якое раней нават лічылася немагчымым. Напрыклад, ключ `price` у целе JSON (які можа быць укладзеным), які прыходзіць з запыту.

Больш ніякіх няправільна набраных імёнаў ключоў, пераходаў туды-сюды паміж дакументамі, або пракручванняў увех і ўніз, каб нарэште даведацца, выкарытоўваеце Вы `username` ці `user_name`.

### Кароткасць

Фрэймворк мае разумныя **значэння па змаўчанні** з дадатковымі канфігурацыямі для ўсяго. Усе параметры могуць быць дакладна настроены, каб рабіць тое, што вам трэба, і вызначаць неабходны API.

Але па змаўчанні ўсё гэта **"проста працуе"**.

### Праверка дадзеных

* Праверка большасці (ці ўсіх?) **тыпаў дадзеных** Python, у тым ліку:
    * JSON аб'ектаў (`dict`).
    * JSON масіў (`list`) з вызначэннем тыпаў элемента.
    * Радковыя (`str`) палі з вызначэнне мінімальнай і максімальнай даўжыні.
    * Лічбы (`int`, `float`) з мінімальнымі і максімальнымі значэннямі і г.д.

* Праверка для больш экзатычных тыпаў, такіх як:
    * URL.
    * Email.
    * UUID.
    * ...і іншых.

Усе праверкі выконваюцца надзейным і добра зарэкамендавалым сябе **Pydantic**.

### Бяспека і аўтэнтыфікацыя

Бяспека і аўтэнтыфікацыя інтэграваныя. Без якіх-небудзь кампрамісаў з базамі дадзеных або мадэлямі дадзеных.

Усе схемы бяспекі, вызначаныя ў OpenAPI, у тым ліку:

* HTTP Basic.
* **OAuth2** (таксама з **JWT токенамі**). Паглядзіце кіраўніцтва [OAuth2 with JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.
* API ключы ў:
    * Загалоўках.
    * Параметраз запросаў.
    * Cookies і г.д.

Плюс усе функцыі бяспекі ад Starlette (у тым ліку **session cookies**).

Усё створана ў выглядзе шматразовых інструментаў і кампанентаў, якія лёгка інтэгруюцца з вашымі сістэмамі, сховішчамі дадзеных, рэляцыйнымі базамі дадзеных і базамі дадзеных NoSQL і г.д.

### Увядзенне залежнасцей

FastAPI ўключае надзвычай простую ў выкарыстанні, але надзвычай магутную сістэму <abbr title='таксама вядомую як "components", "resources", "services", "providers"'><strong>ўвядзення залежнасцей</strong></abbr>.

* Нават залежнасці могуць мець залежнасці, ствараючы іерархію або **"граф" залежнасцей**.
* Усё **аўтаматычна апрацоўваецца** фрэймворкам.
* Усе залежнасці могуць запатрабаваць дадзеныя з запытаў і **павялічыць аперацыю шляху** абмежаваннямі і аўтаматычнай дакументацыей.
* **Аўтаматычная праверка** нават для параметраў *аперацый шляху*, вызначаных у залежнасцях.
* Падтрымка складаных сістэм аўтэнтыфікацыі карыстальнікаў, **злучэнняў з базамі дадзеных** і г.д.
* **Без кампрамісаў** з базамі дадзеных, інтэрфейсамі і г.д. Але простая інтэграцыя з усімі імі.

### Неабмежаванасць "плагінаў"

Ці іншымі словамі, яны не патрэбныя, імпартуйце і выкарыстоўвайце неабходны Вам код.

Усе інтэграцыі распрацаваны настолькі простымі ў выкарыстанні (з залежнасцямі), што вы можаце стварыць "плагін" для вашай праграмы ў 2 радках кода, выкарыстоўваючы тую ж структуру і сінтаксіс, якія выкарыстоўваюцца для вашых *аперацый шляху*.

### Пратэставаны

* 100% <abbr title="Колькасць аўтаматычна тэстуемага кода">пакрыццё тэстами</abbr>.
* 100% <abbr title="Анатацыі тыпаў Python, дзякуючы гэтаму ваш рэдактар і знешнія інструменты могуць забяспечыць вам лепшую падтрымку">анатацыі тыпаў</abbr> кодавай базы
* Выкарыстоўваецца ў прадакшн праграмах.

## Магчымасці Starlette

**FastAPI** заснаваны і цалкам сумяшчальны са <a href="https://www.starlette.io/" class="external-link" target="_blank"><strong>Starlette</strong></a>. Такім чынам, любы дадатковы код Starlette, які ў вас ёсць, таксама будзе працаваць.

`FastAPI` з'яўляецца падкласам `Starlette`. Таму калі вы ўжо ведаеце або карыстаецеся Starlette, большасць функцый будзе працаваць такім жа чынам.

З **FastAPI** вы атрымліваеце ўсе магчымасці **Starlette**, паколькі FastAPI - гэта проста Starlette на стэроідах:
 
*Сур'ёзна ўражлівая прадукцыйнасць. Гэта <a href="https://github.com/encode/starlette#performance" class="external-link" target="_blank">Гэта адзін з самых хуткіх даступных фрэймворкаў Python, нароўні з  **NodeJS** і **Go**</a>.
* Падтрымка **WebSocket**.
* Фонавыя задачы ў працэсах.
* Падзеі запуску і выключэння.
* Тэставы кліент, пабудаваны на HTTPX.
* **CORS**, GZip, Статычныя файлы, Патокавыя адказы.
* Падтрымка **Сесій і Cookie**.
* 100% пакрыццё тыстамі .
* 100% анатацыі тыпаў кодавай базы.

## Магчымасці Pydantic

**FastAPI** заснаваны і цалкам сумяшчальны с <a href="https://pydantic-docs.helpmanual.io" class="external-link" target="_blank"><strong>Pydantic</strong></a>. Такім чынам, любы дадатковы код Pydantic, які ў вас ёсць, таксама будзе працаваць.

Уключаючы знешнія бібліятэкі, таксама заснаваныя на Pydantic, такія як: <abbr title="Object-Relational Mapper">ORM</abbr>s, <abbr title="Object-Document Mapper">ODM</abbr>для баз дадзеных.

Гэта таксама азначае, што ў многіх выпадках вы можаце перадаць той жа аб'ект, які атрымліваеце з запыту, **непасрэдна ў базу дадзеных**, бо ўсё правяраецца аўтаматычна.

Тое ж самае і наадварот, у многіх выпадках вы можаце проста перадаць атрыманы аб'ект з базы дадзеных **непасрэдна кліенту**.

З **FastAPI** вы атрымліваеце ўсе функцыі **Pydantic** (паколькі FastAPI заснаваны на Pydantic для апрацоўкі ўсіх дадзеных):

* **Ніякіх мазгатрахаў**:
    * Ніякіх мікрамоў для вызначэння новых схем
    * Калі вы ведаеце тыпы Python, вы ведаеце, як выкарыстоўваць Pydantic.
* Цудоўна сумяшчаецца з Вашым **<abbr title="Integrated Development Environment, similar to a code editor">IDE</abbr>/<abbr title="Праграма для праверкі кода на памылкі">лінтерам</abbr>/мозгам**:
    * Паколькі струкруты дадзеных pydantic - гэта толькі экзэмпляры класаў, вызначыныя Вамі. Аўтадапаўненне, лінтынт, mypy і ваша інтуіцыя павінны правільна працаваць з вашымі праверанымі дадзенымі.
* **Хуткасць**:
    * у <a href="https://pydantic-docs.helpmanual.io/benchmarks/" class="external-link" target="_blank">бэнчмарках</a>  хутчэй, чым усе іншыя пратэставаныя бібліятэкі.
* Праверка **складаных структур**:
    * Выкарыстанне іерархічных мадэляў Pydantic, `List`, `Dict` і г.д з Python-модуля `typing`
    * валідатары дазваляюць выразна і лёгка вызначаць, правяраць і дакументаваць складаныя схемы дадзеных у выглядзе схемы JSON.
    * Вы можаце мець глыбока **ўкладзеныя аб'екты JSON**, правяраць іх усе і анатаваць.
* **Пашыральнасць**:
    * Pydantic дазваляе вызначаць карыстацкія тыпы дадзеных або пашыраць праверку метадамі мадэлі, з дапамогай праверачных дэкаратараў.
* 100% пакрыццё тэстамі.
