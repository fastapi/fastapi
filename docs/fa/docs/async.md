# هم‌زمانی و async / await

جزئیات در مورد سینتکس `async def` برای *توابع عملیات مسیر* و یه مقدار اطلاعات پس‌زمینه در مورد کد ناهم‌زمان، هم‌زمانی و موازی‌سازی.

## عجله داری؟

<abbr title="too long; didn't read"><strong>TL;DR:</strong></abbr>

اگه از کتابخونه‌های third-party استفاده می‌کنی که بهت می‌گن باید با `await` صداشون کنی، مثل:

```Python
results = await some_library()
```

اون وقت، *توابع عملیات مسیرت* رو با `async def` تعریف کن، مثل:

```Python hl_lines="2"
@app.get('/')
async def read_results():
    results = await some_library()
    return results
```

/// note

فقط توی توابعی که با `async def` ساخته شدن می‌تونی از `await` استفاده کنی.

///

---

اگه از یه کتابخونه third-party استفاده می‌کنی که با یه چیزی (مثل دیتابیس، API، فایل سیستم و غیره) ارتباط داره و از `await` پشتیبانی نمی‌کنه (که الان بیشتر کتابخونه‌های دیتابیس اینجورین)، اون وقت *توابع عملیات مسیرت* رو مثل همیشه با `def` معمولی تعریف کن، مثل:

```Python hl_lines="2"
@app.get('/')
def results():
    results = some_library()
    return results
```

---

اگه برنامه‌ات (به هر دلیلی) نیازی به ارتباط با چیز دیگه‌ای نداره و منتظر جوابش نمی‌مونه، از `async def` استفاده کن.

---

اگه نمی‌دونی چیکار کنی، از `def` معمولی استفاده کن.

---

**توجه**: می‌تونی به هر تعداد که لازم داری، `def` و `async def` رو توی *توابع عملیات مسیرت* قاطی کنی و هر کدوم رو با بهترین گزینه برای خودت تعریف کنی. FastAPI خودش کار درست رو باهاشون انجام می‌ده.

به هر حال، توی هر کدوم از حالت‌های بالا، FastAPI هنوز به صورت ناهم‌زمان کار می‌کنه و خیلی سریع عمل می‌کنه.

ولی با رعایت نکات بالا، می‌تونه یه سری بهینه‌سازی‌های عملکردی هم انجام بده.

## جزئیات فنی

نسخه‌های مدرن پایتون از **"کد ناهم‌زمان"** پشتیبانی می‌کنن که با چیزی به اسم **"coroutines"** کار می‌کنه و از سینتکس **`async` و `await`** استفاده می‌کنه.

بیاید این جمله رو تکه‌تکه بررسی کنیم توی بخش‌های زیر:

* **کد ناهم‌زمان**
* **`async` و `await`**
* **Coroutines**

## کد ناهم‌زمان

کد ناهم‌زمان یعنی زبون برنامه‌نویسی 💬 یه راهی داره که به کامپیوتر / برنامه 🤖 بگه توی یه جای کد، باید منتظر بمونه تا *یه چیز دیگه* جایی دیگه تموم بشه. فرض کنیم اون *چیز دیگه* اسمش "فایل کند" 📝 باشه.

پس توی اون مدت، کامپیوتر می‌تونه بره یه کار دیگه انجام بده، تا وقتی که "فایل کند" 📝 تموم بشه.

بعدش کامپیوتر / برنامه 🤖 هر وقت فرصتی پیدا کرد برمی‌گرده، چون دوباره منتظره یا وقتی همه کارایی که اون لحظه داشته تموم شدن. اون موقع می‌چرخه ببینه کدوم از کارایی که منتظرشون بوده تموم شدن و هر کاری که باید باهاشون بکنه رو انجام می‌ده.

بعدش، اولین کاری که تموم شده (مثلاً "فایل کند" 📝) رو برمی‌داره و هر چیزی که باید باهاش انجام بده رو ادامه می‌ده.

این "منتظر چیزی دیگه بودن" معمولاً به عملیات <abbr title="ورودی و خروجی">I/O</abbr> اشاره داره که نسبتاً "کند" هستن (در مقایسه با سرعت پردازنده و حافظه RAM)، مثل منتظر موندن برای:

* داده‌هایی که از کلاینت از طریق شبکه فرستاده می‌شن
* داده‌هایی که برنامه‌ات فرستاده تا از طریق شبکه به کلاینت برسه
* محتوای یه فایل توی دیسک که سیستم باید بخوندش و به برنامه‌ات بده
* محتوایی که برنامه‌ات به سیستم داده تا توی دیسک بنویسه
* یه عملیات API از راه دور
* یه عملیات دیتابیس که تموم بشه
* یه کوئری دیتابیس که نتیجه‌ش برگرده
* و غیره

چون بیشتر زمان اجرا صرف منتظر موندن برای عملیات <abbr title="ورودی و خروجی">I/O</abbr> می‌شه، به اینا می‌گن عملیات "I/O bound".

بهش می‌گن "ناهم‌زمان" چون کامپیوتر / برنامه مجبور نیست با کار کند "هم‌زمان" باشه، یعنی دقیقاً لحظه‌ای که کار تموم می‌شه منتظرش بمونه و هیچ کاری نکنه تا نتیجه رو بگیره و ادامه بده.

به جاش، چون یه سیستم "ناهم‌زمانه"، وقتی کار تموم شد، می‌تونه یه کم توی صف منتظر بمونه (چند میکروثانیه) تا کامپیوتر / برنامه هر کاری که رفته انجام بده رو تموم کنه، بعد برگرده نتیجه رو بگیره و باهاش کار کنه.

برای "هم‌زمان" (برخلاف "ناهم‌زمان") معمولاً از اصطلاح "ترتیبی" هم استفاده می‌کنن، چون کامپیوتر / برنامه همه مراحل رو به ترتیب دنبال می‌کنه قبل از اینکه بره سراغ یه کار دیگه، حتی اگه اون مراحل شامل منتظر موندن باشن.

### هم‌زمانی و برگرها

ایده **ناهم‌زمان** که بالا توضیح دادم گاهی بهش **"هم‌زمانی"** هم می‌گن. این با **"موازی‌سازی"** فرق داره.

**هم‌زمانی** و **موازی‌سازی** هر دو به "اتفاق افتادن چیزای مختلف تقریباً همزمان" ربط دارن.

ولی جزئیات بین *هم‌زمانی* و *موازی‌سازی* خیلی متفاوته.

برای دیدن فرقش، این داستان برگرها رو تصور کن:

### برگرهای هم‌زمان

با عشقت می‌ری فست‌فود بخری، توی صف وایمیستی تا صندوق‌دار سفارش آدمای جلوییت رو بگیره. 😍

<img src="/img/async/concurrent-burgers/concurrent-burgers-01.png" class="illustration">

بعد نوبتت می‌شه، سفارش دو تا برگر خیلی شیک برای خودت و عشقت می‌دی. 🍔🍔

<img src="/img/async/concurrent-burgers/concurrent-burgers-02.png" class="illustration">

صندوق‌دار یه چیزی به آشپز توی آشپزخونه می‌گه که بدونن باید برگراتو آماده کنن (هرچند الان دارن برگرای مشتریای قبلی رو درست می‌کنن).

<img src="/img/async/concurrent-burgers/concurrent-burgers-03.png" class="illustration">

پول رو می‌دی. 💸

صندوق‌دار شماره نوبتت رو بهت می‌ده.

<img src="/img/async/concurrent-burgers/concurrent-burgers-04.png" class="illustration">

تا وقتی منتظری، با عشقت می‌ری یه میز انتخاب می‌کنی، می‌شینی و کلی باهم حرف می‌زنی (چون برگرات خیلی شیکن و آماده کردنشون طول می‌کشه).

وقتی رو میز با عشقت نشستی و منتظر برگرهایی، می‌تونی اون مدت رو صرف تحسین کردن این بکنی که عشقت چقدر باحال، ناز و باهوشه ✨😍✨.

<img src="/img/async/concurrent-burgers/concurrent-burgers-05.png" class="illustration">

توی این مدت که با عشقت حرف می‌زنی، هر چند وقت یه بار شماره‌ای که رو پیشخون نشون می‌ده رو چک می‌کنی که ببینی نوبتت شده یا نه.

بعد بالاخره نوبتت می‌شه. می‌ری پیشخون، برگراتو می‌گیری و برمی‌گردی سر میز.

<img src="/img/async/concurrent-burgers/concurrent-burgers-06.png" class="illustration">

تو و عشقت برگرها رو می‌خورید و یه وقت خوب باهم دارید. ✨

<img src="/img/async/concurrent-burgers/concurrent-burgers-07.png" class="illustration">

/// اطلاعات

تصاویر قشنگ از <a href="https://www.instagram.com/ketrinadrawsalot" class="external-link" target="_blank">کترینا تامپسون</a>. 🎨

///

---

تصور کن تو توی این داستان کامپیوتر / برنامه 🤖 هستی.

تا وقتی توی صفی، فقط بیکاری 😴 و منتظر نوبتت هستی، کار خیلی "مفیدی" نمی‌کنی. ولی صف سریع پیش می‌ره چون صندوق‌دار فقط سفارش می‌گیره (آماده نمی‌کنه)، پس اشکالی نداره.

بعد که نوبتت می‌شه، کار "مفید" واقعی می‌کنی، منو رو نگاه می‌کنی، تصمیم می‌گیری چی می‌خوای، انتخاب عشقت رو می‌پرسی، پول می‌دی، چک می‌کنی اسکناس یا کارت درست باشه، مطمئن می‌شی درست حساب شده، سفارش رو چک می‌کنی که درست باشه و غیره.

ولی بعدش، حتی اگه هنوز برگراتو نگرفتی، کارت با صندوق‌دار "متوقف" ⏸ می‌شه، چون باید منتظر بمونی 🕙 تا برگرات آماده بشن.

ولی وقتی از پیشخون دور می‌شی و با شماره نوبتت سر میز می‌شینی، می‌تونی توجهت رو به عشقت عوض کنی 🔀 و رو اون "کار" ⏯ 🤓 کنی. اون موقع دوباره یه کار خیلی "مفید" داری که معاشقه با عشقته 😍.

بعد صندوق‌دار 💁 با گذاشتن شماره‌ات رو تابلوی پیشخون می‌گه "من با درست کردن برگرا تموم کردم"، ولی تو فوراً مثل دیوونه‌ها وقتی شماره‌ات میاد نمی‌پری. می‌دونی کسی برگراتو نمی‌دزده چون شماره نوبتت رو داری و اونا هم مال خودشون رو دارن.

پس منتظر می‌مونی تا عشقت داستانش رو تموم کنه (کار فعلی ⏯ / تسک در حال پردازش 🤓 تموم بشه)، با لبخند آروم می‌گی که می‌ری برگرا رو بیاری ⏸.

بعد می‌ری پیشخون 🔀، به تسک اولیه که حالا تموم شده ⏯ برمی‌گردی، برگرا رو می‌گیری، تشکر می‌کنی و می‌برشون سر میز. این مرحله / تسک تعامل با پیشخون رو تموم می‌کنه ⏹. این خودش یه تسک جدید درست می‌کنه، یعنی "خوردن برگرا" 🔀 ⏯، ولی تسک قبلی "گرفتن برگرا" تموم شده ⏹.

### برگرهای موازی

حالا فرض کن اینا "برگرهای هم‌زمان" نیستن، بلکه "برگرهای موازین".

با عشقت می‌ری فست‌فود موازی بخری.

توی صف وایمیستی در حالی که چند تا (مثلاً 8 تا) صندوق‌دار که همزمان آشپز هم هستن سفارش آدمای جلوییت رو می‌گیرن.

همه قبل از تو منتظرن تا برگراشون آماده بشه و از پیشخون برن چون هر کدوم از 8 تا صندوق‌دار می‌ره و برگر رو همون موقع درست می‌کنه قبل از اینکه سفارش بعدی رو بگیره.

<img src="/img/async/parallel-burgers/parallel-burgers-01.png" class="illustration">

بالاخره نوبتت می‌شه، سفارش دو تا برگر خیلی شیک برای خودت و عشقت می‌دی.

پول رو می‌دی 💸.

<img src="/img/async/parallel-burgers/parallel-burgers-02.png" class="illustration">

صندوق‌دار می‌ره آشپزخونه.

منتظر می‌مونی، جلوی پیشخون وایستاده‌ای 🕙، که کسی قبل از تو برگراتو نگیره، چون شماره نوبت نیست.

<img src="/img/async/parallel-burgers/parallel-burgers-03.png" class="illustration">

چون تو و عشقت مشغول اینی که نذاری کسی جلوتون دربیاد و برگراتو بگیره، نمی‌تونی به عشقت توجه کنی. 😞

این کار "هم‌زمانه"، تو با صندوق‌دار/آشپز 👨‍🍳 "هم‌زمان" هستی. باید منتظر بمونی 🕙 و دقیقاً همون لحظه که صندوق‌دار/آشپز 👨‍🍳 برگرا رو تموم می‌کنه و بهت می‌ده اونجا باشی، وگرنه ممکنه یکی دیگه برشون داره.

<img src="/img/async/parallel-burgers/parallel-burgers-04.png" class="illustration">

بعد بالاخره صندوق‌دار/آشپزت 👨‍🍳 بعد از یه انتظار طولانی 🕙 جلوی پیشخون با برگرا برمی‌گرده.

<img src="/img/async/parallel-burgers/parallel-burgers-05.png" class="illustration">

برگراتو می‌گیری و با عشقت می‌ری سر میز.

فقط می‌خوریدشون و تموم می‌شه. ⏹

<img src="/img/async/parallel-burgers/parallel-burgers-06.png" class="illustration">

چون بیشتر وقتتون صرف انتظار 🕙 جلوی پیشخون شده، حرف زدن یا معاشقه زیادی نبوده. 😞

/// اطلاعات

تصاویر قشنگ از <a href="https://www.instagram.com/ketrinadrawsalot" class="external-link" target="_blank">کترینا تامپسون</a>. 🎨

///

---

توی این سناریوی برگرهای موازی، تو یه کامپیوتر / برنامه 🤖 با دو تا پردازنده (تو و عشقت) هستی که هردوتون مدت طولانی منتظر 🕙 و متمرکز ⏯ روی "انتظار جلوی پیشخون" 🕙 بودید.

فست‌فود 8 تا پردازنده (صندوق‌دار/آشپز) داره. در حالی که فست‌فود برگرهای هم‌زمان ممکنه فقط 2 تا (یه صندوق‌دار و یه آشپز) داشته باشه.

ولی با این حال، تجربه نهایی خیلی خوب نیست. 😞

---

این یه داستان معادل موازی برای برگرها بود. 🍔

برای یه مثال "واقعی‌تر" از زندگی، یه بانک رو تصور کن.

تا همین چند وقت پیش، بیشتر بانک‌ها چند تا صندوق‌دار 👨‍💼👨‍💼👨‍💼👨‍💼 داشتن و یه صف بزرگ 🕙🕙🕙🕙🕙🕙🕙🕙.

همه صندوق‌دارا با یه مشتری بعد از اون یکی کار می‌کردن 👨‍💼⏯.

و تو باید توی صف کلی منتظر می‌موندی 🕙 وگرنه نوبتت رو از دست می‌دادی.

احتمالاً نمی‌خوای عشقت 😍 رو با خودت ببری بانک 🏦 برای کارای روزمره.

### نتیجه‌گیری برگرها

توی این سناریوی "فست‌فود برگر با عشقت"، چون کلی انتظار 🕙 داری، خیلی منطقی‌تره که یه سیستم هم‌زمان ⏸🔀⏯ داشته باشی.

این برای بیشتر برنامه‌های وب هم صدق می‌کنه.

کاربرای خیلی خیلی زیاد، ولی سرورت منتظره 🕙 تا اتصال نه‌چندان خوبشون درخواستاشون رو بفرسته.

و بعد دوباره منتظره 🕙 تا جواب‌ها برگردن.

این "انتظار" 🕙 توی میکروثانیه‌ها اندازه‌گیری می‌شه، ولی در کل، جمعش می‌شه کلی انتظار.

برای همین استفاده از کد ناهم‌زمان ⏸🔀⏯ برای APIهای وب خیلی منطقیه.

این نوع ناهم‌زمانی همون چیزیه که NodeJS رو محبوب کرد (هرچند NodeJS موازی نیست) و نقطه قوت زبان برنامه‌نویسی Go هم همینه.

و این همون سطح عملکردیه که با **FastAPI** به دست میاری.

و چون می‌تونی هم‌زمانی و موازی‌سازی رو همزمان داشته باشی، عملکرد بهتری نسبت به بیشتر فریم‌ورک‌های تست‌شده NodeJS و هم‌تراز با Go که یه زبان کامپایل‌شده نزدیک به C هست می‌گیرید <a href="https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=query&l=zijmkf-1" class="external-link" target="_blank">(همه اینا به لطف Starlette)</a>.

### آیا هم‌زمانی از موازی‌سازی بهتره؟

نه! این نتیجه داستان نیست.

هم‌زمانی با موازی‌سازی فرق داره. و توی **سناریوهای خاص** که کلی انتظار دارن بهتره. به همین دلیل، معمولاً برای توسعه برنامه‌های وب خیلی بهتر از موازی‌سازیه. ولی نه برای همه چیز.

برای اینکه تعادل رو حفظ کنیم، این داستان کوتاه رو تصور کن:

> باید یه خونه بزرگ و کثیف رو تمیز کنی.

*همینه، کل داستان همینه*.

---

هیچ انتظاری 🕙 نیست، فقط کلی کار که باید توی جاهای مختلف خونه انجام بشه.

می‌تونی مثل مثال برگرها نوبت بذاری، اول پذیرایی، بعد آشپزخونه، ولی چون منتظر چیزی نیستی 🕙 و فقط داری تمیز می‌کنی، نوبت‌ها چیزی رو عوض نمی‌کنن.

با نوبت یا بدون نوبت (هم‌زمانی) همون مقدار زمان می‌بره تا تموم کنی و همون مقدار کار رو انجام دادی.

ولی توی این موقعیت، اگه بتونی اون 8 تا صندوق‌دار/آشپز/حالا-تمیزکار رو بیاری و هر کدوم (به علاوه خودت) یه بخش خونه رو تمیز کنه، می‌تونی همه کار رو **موازی** انجام بدی، با کمک اضافه، و خیلی زودتر تموم کنی.

توی این سناریو، هر کدوم از تمیزکارا (از جمله تو) یه پردازنده‌ان که دارن بخش خودشون از کار رو انجام می‌دن.

و چون بیشتر زمان اجرا صرف کار واقعی می‌شه (نه انتظار)، و کار توی کامپیوتر توسط <abbr title="واحد پردازش مرکزی">CPU</abbr> انجام می‌شه، به این مشکلات می‌گن "CPU bound".

---

مثال‌های رایج عملیات CPU bound چیزایی هستن که نیاز به پردازش ریاضی پیچیده دارن.

مثلاً:

* پردازش **صدا** یا **تصویر**.
* **بینایی کامپیوتری**: یه تصویر از میلیون‌ها پیکسل تشکیل شده، هر پیکسل 3 تا مقدار / رنگ داره، پردازشش معمولاً نیاز داره روی این پیکسلا همزمان چیزی محاسبه بشه.
* **یادگیری ماشین**: معمولاً کلی ضرب "ماتریس" و "بردار" می‌خواد. یه صفحه گسترده بزرگ با اعداد رو تصور کن که همه‌شون رو همزمان ضرب می‌کنی.
* **یادگیری عمیق**: یه زیرشاخه از یادگیری ماشینه، پس همون چیزا صدق می‌کنه. فقط اینجا یه صفحه گسترده نیست، بلکه یه مجموعه بزرگ از اونا داری و توی خیلی موارد از یه پردازنده خاص برای ساختن یا استفاده از این مدل‌ها استفاده می‌کنی.

### هم‌زمانی + موازی‌سازی: وب + یادگیری ماشین

با **FastAPI** می‌تونی از هم‌زمانی که توی توسعه وب خیلی رایجه (همون جذابیت اصلی NodeJS) استفاده کنی.

ولی می‌تونی از مزایای موازی‌سازی و multiprocessing (اجرای چند پروسه به صورت موازی) هم برای کارای **CPU bound** مثل سیستم‌های یادگیری ماشین بهره ببری.

این، به علاوه این واقعیت ساده که پایتون زبان اصلی برای **علوم داده**، یادگیری ماشین و به‌خصوص یادگیری عمیقه، باعث می‌شه FastAPI یه گزینه خیلی خوب برای APIها و برنامه‌های وب علوم داده / یادگیری ماشین باشه (بین خیلی چیزای دیگه).

برای دیدن اینکه چطور توی محیط واقعی این موازی‌سازی رو پیاده کنی، بخش [استقرار](deployment/index.md){.internal-link target=_blank} رو ببین.

## `async` و `await`

نسخه‌های مدرن پایتون یه راه خیلی ساده و قابل‌فهم برای تعریف کد ناهم‌زمان دارن. این باعث می‌شه مثل کد "ترتیبی" معمولی به نظر بیاد و توی لحظه‌های درست برات "منتظر بمونه".

وقتی یه عملیاتی هست که باید قبل از دادن نتیجه منتظر بمونه و از این قابلیت‌های جدید پایتون پشتیبانی می‌کنه، می‌تونی اینجوری کدنویسی کنی:

```Python
burgers = await get_burgers(2)
```

note کلیدی اینجا `await` هست. به پایتون می‌گه باید منتظر بمونه ⏸ تا `get_burgers(2)` کارش 🕙 تموم بشه قبل از اینکه نتیجه رو توی `burgers` ذخیره کنه. با این، پایتون می‌فهمه که می‌تونه بره یه کار دیگه 🔀 ⏯ انجام بده توی این مدت (مثلاً یه درخواست دیگه رو بگیره).

برای اینکه `await` کار کنه، باید توی یه تابع باشه که از این ناهم‌زمانی پشتیبانی کنه. برای این کار، فقط با `async def` تعریفش کن:

```Python hl_lines="1"
async def get_burgers(number: int):
    # یه سری کار ناهم‌زمان برای ساختن برگرا انجام بده
    return burgers
```

...به جای `def`:

```Python hl_lines="2"
# این ناهم‌زمان نیست
def get_sequential_burgers(number: int):
    # یه سری کار ترتیبی برای ساختن برگرا انجام بده
    return burgers
```

با `async def`، پایتون می‌فهمه که توی اون تابع باید حواسش به عبارت‌های `await` باشه و می‌تونه اجرای اون تابع رو "متوقف" کنه ⏸ و بره یه کار دیگه بکنه 🔀 قبل از اینکه برگرده.

وقتی می‌خوای یه تابع `async def` رو صدا کنی، باید "منتظرش" بمونی. پس این کار نمی‌کنه:

```Python
# این کار نمی‌کنه، چون get_burgers با async def تعریف شده
burgers = get_burgers(2)
```

---

پس اگه از یه کتابخونه استفاده می‌کنی که می‌گه می‌تونی با `await` صداش کنی، باید *توابع عملیات مسیرت* که ازش استفاده می‌کنن رو با `async def` بسازی، مثل:

```Python hl_lines="2-3"
@app.get('/burgers')
async def read_burgers():
    burgers = await get_burgers(2)
    return burgers
```

### جزئیات فنی‌تر

شاید متوجه شده باشی که `await` فقط توی توابعی که با `async def` تعریف شدن می‌تونه استفاده بشه.

ولی در عین حال، توابعی که با `async def` تعریف شدن باید "منتظر" بمونن. پس توابع با `async def` فقط توی توابع دیگه‌ای که با `async def` تعریف شدن می‌تونن صدا بشن.

حالا، مرغ و تخم‌مرغ کدوم اول بود؟ چطور اولین تابع `async` رو صدا می‌کنی؟

اگه با **FastAPI** کار می‌کنی، لازم نیست نگران این باشی، چون اون "اولین" تابع همون *تابع عملیات مسیرت* هست و FastAPI می‌دونه چطور کار درست رو بکنه.

ولی اگه بخوای بدون FastAPI از `async` / `await` استفاده کنی، اونم می‌تونی.

### کد ناهم‌زمان خودت رو بنویس

Starlette (و **FastAPI**) بر پایه <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a> هستن، که باعث می‌شه با هر دو کتابخونه استاندارد پایتون <a href="https://docs.python.org/3/library/asyncio-task.html" class="external-link" target="_blank">asyncio</a> و <a href="https://trio.readthedocs.io/en/stable/" class="external-link" target="_blank">Trio</a> سازگار باشه.

به‌خصوص، می‌تونی مستقیماً از <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a> برای موارد پیشرفته‌تر هم‌زمانی که نیاز به الگوهای پیچیده‌تر توی کد خودت داری استفاده کنی.

حتی اگه از FastAPI هم استفاده نمی‌کردی، می‌تونی برنامه‌های ناهم‌زمان خودت رو با <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a> بنویسی که خیلی سازگار باشه و مزایاش (مثل *structured concurrency*) رو بگیری.

من یه کتابخونه دیگه رو بالای AnyIO ساختم، به‌عنوان یه لایه نازک، که تایپ‌نوتیشن‌ها رو بهتر کنه و **اتوکامپلیشن**، **خطاهای درون‌خطی** و غیره رو بهتر کنه. یه مقدمه و آموزش ساده هم داره که بهت کمک می‌کنه **بفهمی** و **کد ناهم‌زمان خودت رو بنویسی**: <a href="https://asyncer.tiangolo.com/" class="external-link" target="_blank">Asyncer</a>. اگه بخوای **کد ناهم‌زمان رو با کد معمولی** (بلاک‌کننده/هم‌زمان) ترکیب کنی خیلی به‌دردت می‌خوره.

### شکل‌های دیگه کد ناهم‌زمان

این سبک استفاده از `async` و `await` توی زبان نسبتاً جدیده.

ولی کار با کد ناهم‌زمان رو خیلی ساده‌تر می‌کنه.

همین سینتکس (یا تقریباً مشابه) تازگی‌ها توی نسخه‌های مدرن جاوااسکریپت (توی مرورگر و NodeJS) هم اضافه شده.

ولی قبل از اون، مدیریت کد ناهم‌زمان خیلی پیچیده‌تر و سخت‌تر بود.

توی نسخه‌های قدیمی‌تر پایتون، می‌تونستی از threadها یا <a href="https://www.gevent.org/" class="external-link" target="_blank">Gevent</a> استفاده کنی. ولی کدش خیلی سخت‌تر فهمیده می‌شه، دیباگ می‌شه و بهش فکر می‌شه.

توی نسخه‌های قدیمی‌تر NodeJS / جاوااسکریپت مرورگر، از "callbackها" استفاده می‌کردی. که منجر به <a href="http://callbackhell.com/" class="external-link" target="_blank">callback hell</a> می‌شد.

## Coroutines

**Coroutine** یه اصطلاح خیلی شیکه برای چیزی که یه تابع `async def` برمی‌گردونه. پایتون می‌فهمه که این یه چیزی مثل تابع هست، که می‌تونه شروع بشه و یه جایی تموم بشه، ولی ممکنه توی خودش هم "متوقف" ⏸ بشه، هر وقت که یه `await` توش باشه.

ولی همه این قابلیت استفاده از کد ناهم‌زمان با `async` و `await` خیلی وقت‌ها خلاصه می‌شه به استفاده از "coroutines". این قابل‌مقایسه‌ست با قابلیت اصلی Go، یعنی "Goroutines".

## نتیجه‌گیری

بیاید همون جمله از بالا رو ببینیم:

> نسخه‌های مدرن پایتون از **"کد ناهم‌زمان"** با چیزی به اسم **"coroutines"** پشتیبانی می‌کنن، با سینتکس **`async` و `await`**.

حالا باید بیشتر براتون جا بیفته. ✨

همه اینا چیزیه که به FastAPI (از طریق Starlette) قدرت می‌ده و باعث می‌شه این عملکرد شگفت‌انگیز رو داشته باشه.

## جزئیات خیلی فنی

/// warning

احتمالاً می‌تونی از این بگذری.

اینا جزئیات خیلی فنی از نحوه کار **FastAPI** زیر پوسته‌ست.

اگه دانش فنی خوبی داری (coroutineها، threadها، بلاک کردن و غیره) و کنجکاوی که FastAPI چطور `async def` رو در مقابل `def` معمولی مدیریت می‌کنه، ادامه بده.

///

### توابع عملیات مسیر

وقتی یه *تابع عملیات مسیر* رو با `def` معمولی به جای `async def` تعریف می‌کنی، توی یه threadpool خارجی اجرا می‌شه که بعدش منتظرش می‌مونن، به جای اینکه مستقیم صدا بشه (چون اگه مستقیم باشه سرور رو بلاک می‌کنه).

اگه از یه فریم‌ورک ناهم‌زمان دیگه اومدی که اینجوری کار نمی‌کنه و عادت داری توابع ساده فقط محاسباتی رو با `def` معمولی برای یه افزایش عملکرد کوچیک (حدود 100 نانوثانیه) تعریف کنی، توجه کن که توی **FastAPI** اثرش برعکسه. توی این موارد، بهتره از `async def` استفاده کنی مگه اینکه *توابع عملیات مسیرت* کدی داشته باشن که عملیات بلاک‌کننده <abbr title="ورودی/خروجی: خوندن یا نوشتن دیسک، ارتباطات شبکه">I/O</abbr> انجام بده.

با این حال، توی هر دو حالت، احتمالش زیاده که **FastAPI** [هنوز سریع‌تر باشه](index.md#performance){.internal-link target=_blank} از (یا حداقل قابل‌مقایسه باشه با) فریم‌ورک قبلی‌ات.

### وابستگی‌ها

همین برای [وابستگی‌ها](tutorial/dependencies/index.md){.internal-link target=_blank} هم صدق می‌کنه. اگه یه وابستگی تابع `def` معمولی باشه به جای `async def`، توی threadpool خارجی اجرا می‌شه.

### زیروابستگی‌ها

می‌تونی چند تا وابستگی و [زیروابستگی](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} داشته باشی که همدیگه رو نیاز دارن (به‌عنوان پارامترهای تعریف تابع)، بعضیا ممکنه با `async def` ساخته بشن و بعضیا با `def` معمولی. بازم کار می‌کنه، و اونایی که با `def` معمولی ساخته شدن توی یه thread خارجی (از threadpool) صدا می‌شن به جای اینکه "منتظر" بمونن.

### توابع کمکی دیگه

هر تابع کمکی دیگه‌ای که مستقیم خودت صداش می‌کنی می‌تونه با `def` معمولی یا `async def` ساخته بشه و FastAPI روی نحوه صداکردنش تأثیر نمی‌ذاره.

این برخلاف توابعی هست که FastAPI برات صدا می‌کنه: *توابع عملیات مسیر* و وابستگی‌ها.

اگه تابع کمکیت یه تابع معمولی با `def` باشه، مستقیم (همونجوری که توی کدت نوشتی) صدا می‌شه، نه توی threadpool، اگه تابع با `async def` ساخته شده باشه، باید وقتی توی کدت صداش می‌کنی براش `await` بذاری.

---

باز هم، اینا جزئیات خیلی فنی‌ان که اگه دنبالشون اومده باشی احتمالاً برات مفیدن.

وگرنه، با راهنمایی‌های بخش بالا: <a href="#in-a-hurry">عجله داری؟</a> باید اوکی باشی.
