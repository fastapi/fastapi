# Предшественники, альтернативы, сравнения

Что вдохновило создать **FastAPI**; сравнение его с альтернативами и чему он у них научился.

## Введение

**FastAPI** не появился бы на свет, если бы не предшествующие разработки.

Было выпущено множество инструментов которые подтолкнули в итоге к его написанию.

Я воздерживался от создания нового фреймворка на протяжении нескольких лет. Поначалу пытался реализовывать все нужные функции, которые сейчас собраны под одной крышей в **FastAPI**, используя всякие разные фреймворки, плагины, инструменты.

Но в какой-то момент не осталось другого выбора, кроме как создать нечто предоставляющее все эти функции сразу – взяв самые лучшие идеи из предыдущих инструментов, объединив их наилучшим образом и используя возможности Python ранее вовсе не доступные (до версии 3.6 – подсказки типов).

## Проекты-прародители

### <a href="https://www.djangoproject.com/" class="external-link" target="_blank">Django</a>

Это самый популярный и авторитетный фреймворк на Python. Он используется для построения систем вроде Instagram.

Django довольно сильно опирается на реляционные базы данных (такие как MySQL или PostgreSQL), поэтому использовать с ним NoSQL базы данных (например, Couchbase, MongoDB, Cassandra и т.п.) в качестве основного хранилища данных – непросто.

Он был создан для генерации HTML-страниц на сервере, а не для реализации API потребляемых современным фронтендом – React, Vue.js, Angular и т.п. – либо другими сервисами взаимодействующими с сервером (например, <abbr title="Интернет вещей">IoT</abbr>).

### <a href="https://www.django-rest-framework.org/" class="external-link" target="_blank">Django REST Framework</a>

DRF создавали как гибкий инструментарий для построения веб-API на основе Django – чтобы расширить REST функционал последнего.

Он используется многими компаниями, среди которых Mozilla, Red Hat и Eventbrite.

Это был один из первых примеров **автоматического документирования API** и это, в частности, было одной из первых идей в изысканиях вокруг будущего **FastAPI**.

!!! info "Справка"
    Django REST Framework написал Tom Christie. Он же автор Starlette и Uvicorn, на которых основан **FastAPI**.

!!! check "В копилку **FastAPI**"
    Автоматическое создание документации API с пользовательским веб-интерфейсом.

### <a href="https://flask.palletsprojects.com" class="external-link" target="_blank">Flask</a>

Flask – это "микрофреймворк", в нём нет интеграции с базами данных и многого другого, что поставляется по умолчанию с Django.

Простота и гибкость его позволяют, например, использовать NoSQL-базы в качестве основного хранилища.

Поскольку он очень простой, он более-менее интуитивно понятен при изучении, но документация местами уходит в технические дебри.

Flask также часто используется для приложений, которым не нужна база данных, управление пользователями и другие "батарейки" поставляемые в изобилии вместе с Django. Хотя многие из этих функций могут быть добавлены с помощью плагинов.

Такая модульность и статус микрофреймворка который может быть расширен в точности под требования разработки стали ключевой особенностью которую я хотел сохранить.

С точки зрения простоты, Flask казался хорошей отправной точкой для построения API. Теперь оставалось найти "Django Rest Framework" для него.

!!! check "В копилку **FastAPI**"
    Идею микрофреймворка. Это позволит легко смешивать и сочетать необходимые инструменты и компоненты.

    Система маршрутизации запросов должна быть простой и лёгкой в использовании.


### <a href="https://requests.readthedocs.io" class="external-link" target="_blank">Requests</a>

На самом деле **FastAPI** не является альтернативой **Requests**. Область их применения совершенно разная.

Вообще говоря, нет ничего необычного в том чтобы использовать Requests *внутри* приложения FastAPI.

Но всё же Requests сам по себе на FastAPI повлиял.

**Requests** – это библиотека для взаимодействия с API в качестве клиента, в то время как **FastAPI** – библиотека для *создания* API (то есть сервера).

Они, скорее, противопоставлены друг другу и дополняют друг друга.

Requests спроектирован просто, интуитивно понятен, очень легок в использовании, с разумными параметрами по умолчанию. В то же время он очень мощный и легко адаптируется под конкретные нужды.

Вот почему, как гласит его официальный сайт:

> Requests – один из самых загружаемых пакетов Python всех времен


Использовать его очень просто. Например, чтобы выполнить запрос `GET`, вы бы написали:

```Python
response = requests.get("http://example.com/some/url")
```

Соответствующая этому запросу *операция пути* на стороне FastAPI может выглядеть так:

```Python hl_lines="1"
@app.get("/some/url")
def read_url():
    return {"message": "Hello World"}
```

Заметьте, как похожи `requests.get(...)` и `@app.get(...)`.

!!! check "В копилку **FastAPI**"
    * Должен быть простой и понятный API.
    * Нужно непосредственно использовать названия HTTP-методов (операций) для упрощения понимания происходящего.
    * Должны быть разумные настройки по умолчанию и широкие возможности для кастомизации.


### <a href="https://swagger.io/" class="external-link" target="_blank">Swagger</a> и <a href="https://github.com/OAI/OpenAPI-Specification/" class="external-link" target="_blank">OpenAPI</a>

Главной функцией, которую я хотел унаследовать от Django REST Framework, была автоматическая документация API.

Затем обнаружилось, что существует стандарт документирования API, использующий JSON (или YAML, расширение JSON), под названием Swagger.

И к нему существует уже готовый пользовательский веб-интерфейс. Таким образом, возможность генерировать документацию Swagger для API позволила бы сразу использовать этот интерфейс.

В какой-то момент Swagger был передан Linux Foundation и переименован в OpenAPI.

Вот почему, когда говорят о версии 2.0, обычно говорят "Swagger", а для версии 3+ "OpenAPI".

!!! check "В копилку **FastAPI**"
    Внедрять и использовать открытые стандарты для спецификаций API вместо самодельных схем.

    А также встроить основанные на стандартах веб-интерфейсы:

    * <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank">Swagger UI</a>
    * <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank">ReDoc</a>

    Эти два были выбраны за популярность и стабильность, хотя, поискав чуть-чуть, легко найти еще десятки разновидностей пользовательских интерфейсов для OpenAPI (которые можно подключить к **FastAPI**).


### REST фреймворки для Flask

Существует несколько REST фреймворков для Flask, но, потратив некоторое время и силы на их изучение, я обнаружил, что многие из них не обновляются или заброшены и имеют нерешённые проблемы из-за которых они непригодны к использованию.

### <a href="https://marshmallow.readthedocs.io/en/stable/" class="external-link" target="_blank">Marshmallow</a>

Одной из основных функций, необходимых системам API, является "<abbr title="также называемая маршаллингом или конвертацией">сериализация</abbr>" данных, то есть преобразование данных из кода (Python) во что-то, что может быть отправлено по сети. Например, превращение объекта содержащего данные из базы данных в объект JSON. Конвертация объекта `datetime` в строку и т.п.

Другая важная функция, необходимая API — валидация данных, позволяющая убедиться, что данные корректны и соответствуют заданным параметрам. К примеру, некоторое поле ожидает тип `int`, а не какую-то произвольную строку. Это особенно полезно для входящих данных.

Без системы валидации данных вам пришлось бы делать все проверки вручную, прямо в коде.

Именно для обеспечения этих функций и была создана Marshmallow. Это отличная библиотека и я много раз пользовался ею раньше.

Но она была создана до того, как в Python появились подсказки типов. То есть, чтобы определить каждую <abbr title="описание структуры данных">схему</abbr>, вам нужно было использовать специальные утилиты и классы, предоставляемые Marshmallow.

!!! check "В копилку **FastAPI**"
    Использовать сам код программы для создания "схем", которые автоматически выдают типы данных и валидируют их.

### <a href="https://webargs.readthedocs.io/en/latest/" class="external-link" target="_blank">Webargs</a>

Другая немаловажная в API функция – <abbr title="чтение и преобразование данных в объекты Python">парсинг</abbr> данных из входящих запросов.

Webargs - инструмент, который был создан для этого и поддерживает несколько фреймворков, включая Flask.

Для валидации данных он использует Marshmallow. А написан теми же авторами.

Это превосходный инструмент и я тоже часто пользовался им до **FastAPI**.

!!! info "Справка"
    Webargs был создан разработчиками Marshmallow.

!!! check "В копилку **FastAPI**"
    Должна присутствовать автоматическая валидация данных входящего запроса.

### <a href="https://apispec.readthedocs.io/en/stable/" class="external-link" target="_blank">APISpec</a>

Marshmallow и Webargs осуществляют парсинг, валидацию и сериализацию данных как плагины.

Но документации API всё ещё не было. Тогда был создан APISpec.

Это плагин для множества фреймворков (в том числе и для Starlette).

Работает он так: вы записываете определение схем, используя формат YAML, внутри докстринга каждой функции, обрабатывающей маршрут.

По ним он генерирует схемы OpenAPI.

Так это работает для Flask, Starlette, Responder и т.п.

Но теперь у нас опять возникает та же проблема – наличие микро-синтаксиса внутри строк Python (большие YAML).

Редактор кода тут особо не поможет. А изменив какие-то параметры или схемы для Marshmallow можно забыть отредактировать докстринг с YAML и сгенерированная схема станет недействительной.

!!! info "Справка"
    APISpec тоже был создан авторами Marshmallow.

!!! check "В копилку **FastAPI**"
    Необходима поддержка открытого стандарта для API – OpenAPI.

### <a href="https://flask-apispec.readthedocs.io/en/latest/" class="external-link" target="_blank">Flask-apispec</a>

Это плагин для Flask, который связывает вместе Webargs, Marshmallow и APISpec.

Он получает информацию от Webargs и Marshmallow, а затем использует APISpec для автоматического создания схемы OpenAPI.

Это отличный, но крайне недооценённый инструмент. Он заслуживает большей популярности, чем многие плагины для Flask. Возможно, это связано с тем, что его документация слишком скудна и абстрактна.

Он избавил от необходимости использовать чужеродный синтаксис YAML внутри докстрингов Python.

Такое сочетание Flask, Flask-apispec, Marshmallow и Webargs было моим любимым стеком при построении бэкенда до появления **FastAPI**.

Использование этого стека привело к созданию нескольких генераторов проектов. Я и некоторые другие команды до сих пор используем их:

* <a href="https://github.com/tiangolo/full-stack" class="external-link" target="_blank">https://github.com/tiangolo/full-stack</a>
* <a href="https://github.com/tiangolo/full-stack-flask-couchbase" class="external-link" target="_blank">https://github.com/tiangolo/full-stack-flask-couchbase</a>
* <a href="https://github.com/tiangolo/full-stack-flask-couchdb" class="external-link" target="_blank">https://github.com/tiangolo/full-stack-flask-couchdb</a>

Эти же самые генераторы проектов стали основой для [Генераторов проектов с **FastAPI**](project-generation.md){.internal-link target=_blank}.

!!! info "Справка"
    Flask-apispec создан теми же самыми авторами Marshmallow.

!!! check "В копилку **FastAPI**"
    Схема OpenAPI должна создаваться автоматически, из того же кода, который осуществляет сериализацию и проверку данных.

### <a href="https://nestjs.com/" class="external-link" target="_blank">NestJS</a> (и <a href="https://angular.io/" class="external-link" target="_blank">Angular</a>)

Тут даже и не Python: NestJS – это фреймворк под NodeJS, написанный на JavaScript (TypeScript) под влиянием Angular.

Он позволяет получить нечто похожее на то, что можно сделать с помощью Flask-apispec.

В него встроена система внедрения зависимостей, подобная оной в Angular 2. Однако требуется предварительная регистрация этих "внедрений" (как и во всех других известных мне системах внедрения зависимостей), что и выглядит многословно и увеличивает повторяемость кода.

Поскольку параметры в нём описываются с помощью типов TypeScript (аналогичных подсказкам типов в Python), поддержка IDE работает довольно хорошо.

Но поскольку данные из TypeScript не сохраняются после компиляции в JavaScript, он не может полагаться на типы для создания валидаторов данных, сериализации и документации одновременно. Из-за этого и еще некоторых архитектурных решений, для валидации, сериализации и автоматической генерации схем, приходится во многих местах добавлять декораторы. В общем, многословие увеличивается.

Еще он не очень хорошо справляется с вложенными моделями. То есть, если в запросе имеется объект JSON, внутренние поля которого, в свою очередь, являются вложенными объектами JSON, то это не может быть должным образом задокументировано и валидировано.

!!! check "В копилку **FastAPI**"
    Задействовать типы языка Python, чтобы пользоваться поддержкой редактора кода.

    Нужна мощная система внедрения зависимостей. Найти способ снизить до минимума повторение кода.

### <a href="https://sanic.readthedocs.io/en/latest/" class="external-link" target="_blank">Sanic</a>

Это был один из первых "супербыстрых" Python-фреймворков основанных на `asyncio`. Конструктивно очень похож на Flask.

!!! note "Технические подробности"
    В нём использовался <a href="https://github.com/MagicStack/uvloop" class="external-link" target="_blank">`uvloop`</a> вместо стандартного конвейера событий `asyncio`. Вот откуда производительность.

    Он явно вдохновил создателей Uvicorn и Starlette – оба сейчас превосходят Sanic в открытых бенчмарках.

!!! check "В копилку **FastAPI**"
    Придумать, как поднять производительность до небес.

    Вот почему **FastAPI** основан на Starlette, самом быстром из имеющихся в наличии фреймворков (по замерам незаинтересованных лиц).

### <a href="https://falconframework.org/" class="external-link" target="_blank">Falcon</a>

Falcon – ещё один высокопроизводительный Python-фреймворк, минималистичный, спроектированный как основа для других фреймворков, например, Hug.

Функции в нём получают два аргумента: "запрос к серверу" и "ответ сервера". Затем вы "читаете" что-то из запроса и "пишите" что-то в ответ.
Из-за такого подхода невозможно описать параметры запроса и тела сообщения через стандартные подсказки типов Python в качестве параметров функции.

Таким образом, и валидацию данных, и их сериализацию, и документацию нужно прописывать вручную. Либо эти функции должны быть встроены во фреймворк, основанный на Falcon, как тот же Hug. Аналогичное разграничение наблюдается и в других фреймворках взявших за основу подход Falcon – один объект запроса и один объект ответа в параметрах.


!!! check "В копилку **FastAPI**"
    Суметь добиться отличной производительности.

    Так же как это было с Hug (поскольку тот основан на Falcon), Falcon надоумил **FastAPI** объявлять параметры `response` (Ответ) в сигнатурах функций.

    Хотя в FastAPI это необязательно и используется в основном для установки заголовков, куки и нестандартных кодов состояния.

### <a href="https://moltenframework.com/" class="external-link" target="_blank">Molten</a>

Molten мне попался на начальной стадии написания **FastAPI**. В нём были похожие задумки:

* Использование подсказок типов.
* Валидация и документирование исходя из этих подсказок.
* Система внедрения зависимостей.

В нём не используются сторонние библиотеки (такие, как Pydantic) для валидации, сериализации и документации – есть своя собственная. Поэтому переиспользовать ее определения типов было бы непросто.

Также требуется несколько более многословная конфигурация. И поскольку он использует стандарт WSGI (а не ASGI), он не может пользоваться преимуществами высокой производительности таких инструментов как Uvicorn, Starlette и Sanic.

Его система внедрения зависимостей требует их предварительной регистрации, а разрешаются зависимости опираясь на объявленные типы. Из-за этого невозможно объявить более одного "компонента", который предоставляет определенный тип.

Маршруты объявляются в единственном месте с использованием функций, объявленных в других местах (вместо использования декораторов, в которые могут быть обёрнуты функции, обрабатывающие конкретные ресурсы). Это больше похоже на Django, чем на Flask и Starlette. Он разделяет в коде вещи, которые по сути связаны довольно тесно.

!!! check "В копилку **FastAPI**"
    Определять дополнительные валидаторы типов, используя значения атрибутов моделей "по умолчанию".
    Это улучшает поддержку IDE, и ранее это не было доступно в Pydantic.

    Фактически это подтолкнуло к доработке Pydantic с целью поддержки такого же стиля объявления валидаторов (теперь этот функционал в Pydantic уже доступен).

### <a href="https://www.hug.rest/" class="external-link" target="_blank">Hug</a>

Hug был одним из первых фреймворков, реализовавших объявление параметров API с использованием подсказок типов Python. Идея была отличная и она подтолкнула другие проекты к такому же подходу.

Фреймворк использовал в декларациях свои внутренние типы, а не стандартные питоновские, но все же это был огромный шаг вперед.

Это также был один из первых фреймворков, генерировавших полную схему API в формате JSON.

Данная схема не придерживалась стандартов вроде OpenAPI и JSON Schema. Поэтому было бы непросто совместить её с другими инструментами типа Swagger UI.
Но опять же, это была очень инновационная идея.

Ещё у него есть интересная и необычная функция: используя один и тот же фреймворк можно создавать и API, и <abbr title="Интерфейс командной строки">CLI</abbr>.

Поскольку он основан на WSGI, старом стандарте для синхронных веб-фреймворков, он не может работать с веб-сокетами и другими модными штуками, но всё равно обладает высокой производительностью.

!!! info "Справка"
    Hug создан Timothy Crosley, автором <a href="https://github.com/timothycrosley/isort" class="external-link" target="_blank">`isort`</a>, отличного инструмента для автоматической сортировки импортов в Python-файлах.

!!! check "В копилку **FastAPI**"
    Hug повлиял на создание некоторых частей APIStar и был одним из инструментов, которые я счел наиболее многообещающими, наряду с APIStar.

    Hug натолкнул на мысли использовать в **FastAPI** подсказки типов Python при объявлении параметров, а также генерировать схему API автоматически.

    Hug подсказал **FastAPI** идею объявлять параметр `response` (Ответ) в функциях, для установки заголовков и куки.

### <a href="https://github.com/encode/apistar" class="external-link" target="_blank">APIStar</a> (<= 0.5)

Непосредственно перед тем, как принять решение о создании **FastAPI**, я обнаружил сервер **APIStar**. Отлично спроектированный, он содержал в себе почти все, что я искал.

Это была одна из первых реализаций фреймворка, использующего подсказки типов для объявления параметров и запросов, которые я когда-либо видел (до NestJS и Molten). Я нашёл его примерно в то же время, что и Hug. Но APIStar уже использовал стандарт OpenAPI.

У него были автоматические валидация, сериализация данных и генерация схемы OpenAPI на основании одних и тех же подсказок типов используемых в нескольких местах.

При определении схемы тела сообщения не использовались те же питоновские подсказки типов, как в Pydantic, это было скорее похоже на Marshmallow, поэтому поддержка IDE была бы не на уровне, но всё же APIStar был лучшим доступным вариантом.

На тот момент у него были лучшие показатели производительности (проигрывающие только Starlette).

Изначально у него не было веб-интерфейса для автоматической документации API, но я знал, что могу добавить к нему Swagger UI.

В APIStar была система внедрения зависимостей. Которая так же требовала предварительной регистрации компонент, как и инструменты описанные ранее. Но, тем не менее, это была отличная штука.

Мне не довелось использовать его в полноценном проекте, поскольку в нем не была реализована интеграция функционала безопасности, поэтому у меня не было случая внести те функции, которые мне уже предоставляли генераторы проектов на базе Flask-apispec. Задача собрать соответствующий пулл-реквест и добавить проекту недостающее отправилась в мой бэклог.

Ну а потом фокус проекта сместился.

Это больше не был API-фреймворк, поскольку автору нужно было сосредоточиться на Starlette.

Ныне APIStar – это набор инструментов для валидации спецификаций OpenAPI, а не веб-фреймворк.

!!! info "Справка"
    APIStar был написан Tom'ом Christie. Тем самым парнем, который создал:

    * Django REST Framework
    * Starlette (на котором основан **FastAPI**)
    * Uvicorn (используемый и Starlette и **FastAPI**)

!!! check "В копилку **FastAPI**"
    Обосновал право **FastAPI** быть.

    Мне показалась блестящей идея объявлять сразу многое (валидация данных, сериализация, документация) через одни и те же типы Python, которые заодно обеспечат и поддержку со стороны IDE.

    После долгих поисков подобного фреймворка и тестирования всевозможных альтернатив, APIStar стал самым лучшим выбором.

    Но потом APIStar прекратил свое существование как веб-сервер и был создан Starlette, который оказался еще лучшей основой для требуемой системы. Это стало последним аргументом в пользу создания **FastAPI**.

    Я считаю **FastAPI** "духовным преемником" APIStar, улучшившим и расширившим его функционал, систему типов, и остальное благодаря урокам, извлечённым из всех упомянутых выше инструментов.

## Что используется в **FastAPI**

### <a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic</a>

Pydantic – это библиотека для объявления валидаций данных, сериализации и документирования (посредством JSON Schema) через подсказки типов Python. Последнее делает ее чрезвычайно понятной интуитивно.

Ее можно сравнить с Marshmallow. Хотя в бенчмарках Pydantic побыстрее. И поскольку она основана на встроенных подсказках типов Python, она отлично поддерживается редакторами кода.

!!! check "**FastAPI** пользуется этим для..."
    ...всей валидации данных, сериализации и автоматического документирования моделей (на основе JSON Schema).

    **FastAPI** затем берёт эти схемы и помещает их в OpenAPI, отдельно от всего остального чем он занимается.

### <a href="https://www.starlette.io/" class="external-link" target="_blank">Starlette</a>

Starlette – это легкий <abbr title="Новый стандарт для построения асинхронных веб-сервисов Python">ASGI</abbr> фреймворк (набор инструментов), который идеален для создания высокопроизводительных asyncio сервисов.

Starlette очень простой, интуитивно понятный. Он разработан таким образом, чтобы быть легко расширяемым и иметь модульные компоненты.

В нём можно найти:

* Реально впечатляющую производительность;
* Поддержку веб-сокетов;
* Внутрипроцессные фоновые задачи;
* Обработка событий старта и завершения приложения;
* Тестовый клиент на основе HTTPX;
* Поддержка CORS, сжатие GZip, раздача статики, потоковая передача данных;
* Поддержка сессий и куки;
* 100% покрытие тестами;
* 100% аннотированный код;
* Малое число сильных зависимостей.

В настоящее время Starlette показывает самую высокую скорость среди Python-фреймворков подвергавшихся тестированию. Быстрее только Uvicorn, который является сервером, а не фреймворком.

Starlette предоставляет весь базовый функционал микрофреймворка.

Но в нем нет валидации данных, сериализации и документирования.

Это в числе основного что добавлет к нему **FastAPI**, и все с использованием подсказок типов (через Pydantic). Это, плюс систему внедрения зависимостей,утилиты безопасности, генерацию схемы OpenAPI и т.д.

!!! note "Технические подробности"
    ASGI – это новый "стандарт" разрабатываемый участниками основной команды Django. Он пока что не является "стандартом Python" (то есть принятым PEP), но процесс принятия запущен.

    Тем не менее, он уже используется в качестве "стандарта" несколькими инструментами.
    Это значительно улучшает совместимость, поскольку вы можете переключиться с Uvicorn на любой другой ASGI-сервер (например, Daphne или Hypercorn) или добавить ASGI-совместимые средства, такие как `python-socketio`.

!!! check "**FastAPI** пользуется этим для..."
    ...всего основного веб-функционала. Не забыв добавить своего впридачу.

    Класс `FastAPI` сам по себе наследуется напрямую от класса `Starlette`.

    Так что, все что вы можете делать с помощью Starlette, вы можете напрямую делать и с **FastAPI**, поскольку в сущности это прокачанный Starlette.

### <a href="https://www.uvicorn.org/" class="external-link" target="_blank">Uvicorn</a>

Uvicorn – быстрый как молния ASGI-сервер, построенный на uvloop и httptools.

Uvicorn является сервером, а не фреймворком. Например, он не предоставляет средств для маршрутизации запросов по ресурсам. Для этого нужна надстройка, такая как Starlette (или **FastAPI**).

Он рекомендуется в качестве сервера для Starlette и **FastAPI**.

!!! check "**FastAPI** рекомендует его как..."
    ...основной веб-сервер для запуска приложения **FastAPI**.

    Вы можете объединить его с Gunicorn, чтобы получить асинхронный многопроцессный сервер.

    Узнать больше подробностей можно в разделе [Развёртывание](deployment/index.md){.internal-link target=_blank}.

## Тестовые замеры и скорость

Чтобы понять, сравнить и увидеть разницу между Uvicorn, Starlette и FastAPI, ознакомьтесь с разделом [Тестовые замеры](benchmarks.md){.internal-link target=_blank}.
