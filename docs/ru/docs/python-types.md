# Введение в аннотации типов Python

Python имеет поддержку необязательных "аннотаций типов".

(* прим. перев. Также используются термины 'подсказки типов' или просто 'аннотации')

**Аннотации типов** - это специальный синтаксис, который позволяет описать ожидаемый <abbr title="например: str, int, float, bool">тип</abbr> переменной.

Объявление типов для ваших переменных позволяет улучшить поддержку вашего кода редакторами и различными инструментами.

Это просто **краткое руководство / напоминание** об аннотациях типов в Python. Оно охватывает самый минимум, необходимый для их использования в **FastAPI**... что, на самом деле, довольно мало.

**FastAPI** целиком основан на аннотациях типов, у них много выгод и преимуществ.

Но даже если вы никогда не будете использовать **FastAPI**, вам будет полезно немного узнать о них.

!!! Заметка
    Если вы являетесь экспертом в Python и уже знаете всё об аннотациях типов, переходите к следующему разделу.

## Мотивация

Давайте начнем с простого примера:

```Python
{!../../../docs_src/python_types/tutorial001.py!}
```

Вызов этой программы выводит:

```
John Doe
```

Эта функция делает следующее:

* Принимает два обязательных аргумента - `first_name` и `last_name`.
* Преобразует первую букву содержимого каждого аргумента в верхний регистр функцией `title()`.
* <abbr title="Объединяет в одно целое, последовательно, друг за другом.">Соединяет</abbr> их через пробел.

```Python hl_lines="2"
{!../../../docs_src/python_types/tutorial001.py!}
```

### Изменим пример

Это очень простая программа.

Но теперь представьте, что вы пишете её с нуля.

В какой-то момент вы бы написали определение функции, у вас были бы готовы параметры...

Но затем вы должны вызвать "тот метод, который преобразует первую букву в верхний регистр".

Кажется, он называется `upper`? Или `uppercase`? `first_uppercase`? `capitalize`?

Тогда вы попробуете с давним другом программиста: автодополнением редактора.

Вы вводите первый параметр функции, `first_name`, затем точку (`.`), а затем нажимаете `Ctrl+Space`, чтобы запустить дополнение.

Но, к сожалению, ничего полезного не выходит:

<img src="/img/python-types/image01.png">

### Добавим типы

Давайте изменим одну строчку из предыдущей версии.

Мы изменим только тот фрагмент, где объявляются параметры функции:

```Python
    first_name, last_name
```

на:

```Python
    first_name: str, last_name: str
```

Вот и все.

Это и есть "аннотации типов" или же просто - "аннотации".:

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial002.py!}
```

Это не то же самое, что и объявление значений по умолчанию, как здесь:

```Python
    first_name="john", last_name="doe"
```

Это другая вещь.

Мы используем символы двоеточия (`:`), а не символы равенства (`=`).

И добавление аннотаций типов обычно не меняет происходящего по сравнению с тем, что произошло бы без аннотаций.

А теперь представьте, что вы снова находитесь в процессе создания этой функции, но уже с аннотациями типов.

Вы так же доходите до момента, когда пытаетесь запустить автодополнение с помощью `Ctrl+Space` и видите:

<img src="/img/python-types/image02.png">

При этом вы можете просматривать варианты, пока не найдёте подходящий:

<img src="/img/python-types/image03.png">

## Больше мотивации

Взгляните на эту функцию, она уже имеет аннотации типов:

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial003.py!}
```

Поскольку теперь редактор знает типы переменных, вы получаете не только автодополнение, но и проверки ошибок:

<img src="/img/python-types/image04.png">

Теперь вы знаете, что вам нужно исправить, преобразовать `age` в строку, используя `str(age)`:

```Python hl_lines="2"
{!../../../docs_src/python_types/tutorial004.py!}
```

## Объявление типов

Вы только что видели основное место для объявления аннотаций типов. Для аннотирования параметров функции.

Это также основное место, где вы можете использовать их в **FastAPI**.

### Простые типы

Вы можете объявлять все стандартные типы Python, а не только `str`.

Можно использовать, к примеру:

* `int`
* `float`
* `bool`
* `bytes`

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial005.py!}
```

### Обобщённые ти́пы с аннотацией параметров

Существуют некоторые структуры данных, которые содержат другие значения, такие как: `dict`, `list`, `set` и `tuple`.
Внутренние значения этих структур тоже могут иметь свой собственный тип.

Такие типы структур данных, включающие в себя значения, имеющие свой собственный тип, называются "обобщёнными типами" (generic).
И их тоже можно объявлять с аннотацией, в том числе, аннотировать и внутренние значения.

Чтобы объявить эти типы и типы внутренних значений, вы можете использовать модуль `typing`, поставляемый со стандартной библиотекой Python.
Этот модуль существует специально для поддержки аннотаций этих типов.

#### Более новые версии Python

Синтаксис использования модуля `typing` **совместим** со всеми версиями, начиная с версии Python 3.6, и более поздними версиями, включая Python 3.9, Python 3.10 и т.д.

По мере развития Python, **новые версии** поставляются с улучшенной поддержкой аннотаций типов и, во многих случаях, вам даже не нужно будет импортировать и использовать модуль `typing` для объявления аннотаций типов.

Если вы можете выбрать более новую версию Python для вашего проекта, то сможете воспользоваться преимуществами этих дополнительных упрощений. Посмотрите на несколько примеров ниже.

#### List

Например, давайте объявим переменную, как `list` (список) содержащий `str` (строки).

=== "Python 3.6 и выше"

    Из модуля `typing` ипортируем `List` (с заглавной `L`):

    ``` Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial006.py!}
    ```

    Объявим переменную с тем же синтаксисом двоеточия (`:`).

    В качестве типа укажем `List`, который импортировали из модуля `typing`.

    Так как список является структурой данных, которая содержит другие данные, у которых тоже определён тип, вы указываете типы внутренних данных в квадратных скобках:

    ```Python hl_lines="4"
    {!> ../../../docs_src/python_types/tutorial006.py!}
    ```

=== "Python 3.9 и выше"

     Объявим переменную с тем же синтаксисом двоеточия (`:`).

    В качестве типа укажем `list`.

    Так как список является структурой данных, которая содержит другие данные, у которых тоже определён тип, вы указываете типы внутренних данных в квадратных скобках:


    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial006_py39.py!}
    ```

!!! Информация
    Внутренние типы заключённые квадратные скобки называются "параметрами типов".

    В этом случае `str` является параметром типа, передаваемым в `List` (или `list` для Python 3.9 и выше).

Это означает: "переменная `items` имеет тип`list`, и каждый элемент из этого списка имеет тип `str`".

!!! Подсказка
    Если вы используете Python 3.9 или выше, вам не обязательно импортировать `List` из модуля `typing`, вместо этого вы можете использовать обычный тип `list`.

Если вы будете так поступать, редактор сможет оказывать вам поддержку даже при обработке элементов списка:

<img src="/img/python-types/image05.png">

Без аннотации типов добиться такого практически невозможно.

Обратите внимание, что переменная `item` является одним из элементов списка `items`.

Но, тем не менее, редактор знает, что это `str` и оказывает нам помощь.

#### Tuple и Set

Вам нужно сделать то же самое, чтобы объявлять `tuple` (кортежи) и `set` (множества).

=== "Python 3.6 и выше"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial007.py!}
    ```

=== "Python 3.9 и выше"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial007_py39.py!}
    ```

Это означает:

* Переменная `items_t` является `tuple` из трёх элементов: `int`, ещё один `int` и `str`.
* Переменная `items_s` является `set` и каждый из её элементов имеет тип `bytes`.

#### Dict

Чтобы определить `dict` (словарь), вам следует передать 2 типа параметров в квадратных скобках, разделённых запятой.

Первый параметр указывает тип для ключей `dict`.

Второй параметр указывает тип для значений `dict`:

=== "Python 3.6 and above"
    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial008.py!}
    ```

=== "Python 3.9 and above"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial008_py39.py!}
    ```

Это означает:

* Переменная `prices` является `dict` (словарём):
    * Ключи этого `dict` имеют тип `str` (допустим, название каждого элемента).
    * Значения этого `dict` имеют тип `float` (допустим, цена каждой позиции).

#### Union

Вы можете объявить, что переменная может быть любого типа из **нескольких типов**, например,`int` или `str`.

В Python 3.6 и выше (включая Python 3.10) вы можете использовать тип `Union` из модуля `typing` и записать внутри квадратных скобок типы, которые допускается принимать.

В Python 3.10 есть также **альтернативный синтаксис**, где вы можете указывать возможные типы, разделив их <abbr title='also called "bitwise or operator", but that meaning is not relevant here'>вертикальной чертой (`|`)</abbr>.

=== "Python 3.6 и выше"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial008b.py!}
    ```

=== "Python 3.10 и выше"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial008b_py310.py!}
    ```

В обоих случаях. это означает, что переменная `item` может быть или `int`, или `str`.

#### Возможное `None`

Вы можете объявить переменную, значение которой может быть, допустим, типа `str`, но также может быть и `None`.

В Python 3.6 и выше (включая Python 3.10), вы можете объявить её импортируя и используя `Optional` из модуля `typing`.

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009.py!}
```

Использование `Optional[str]` вместо обычного `str` позволит вашему редактору помочь вам с обнаружением ошибок, когда вы считали бы, что значение всегда будет иметь тип `str`, хотя на самом деле это может быть также и `None`.

`Optional[Something]` это, на самом деле, укороченное `Union[Something, None]`, эти выражения эквивалентны.

Кроме того, в Python 3.10, вы можете использовать `Something | None`:

=== "Python 3.6 и выше"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial009.py!}
    ```

=== "Python 3.6 и выше, альтернатива"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial009b.py!}
    ```

=== "Python 3.10 и выше"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial009_py310.py!}
    ```

## Использование `Union` или `Optional`
(* прим. перев. Так как в английском языке слово `Optional` означает `необязательный`, в этом блоке разъясняется, как из-за этого может возникнуть путаница при прочтении кода человеком)

Если вы пользуетесь версией Python ниже, чем 3.10, то вот вам совет с моей очень **субъективной** точки зрения:

* 🚨 Избегайте использования `Optional[SomeType]`
* Вместо этого ✨ **используйте `Union[SomeType, None]`** ✨.

Оба этих выражения эквивалентны и "под капотом" они одинаковы, но я бы порекоммендовал`Union` вместо `Optional` потому что слово "**optional**" подразумевает, что значение является необязательным, и на самом деле означает, что "Это может быть `None`", даже если это не является необязательным, а совсем наоборот, всегда должно содержать какое-то значение.

Полагаю, что `Union[str, SomeType]` более чётко описывает происходящее.

Всё дело только в словах и названиях. Но эти слова могут повлиять на то, как вы и ваши коллеги, представляют, что происходит в коде.

В качестве примера, давайте возьмём такую функцию:

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009c.py!}
```

Здесь параметр `name` определён как `Optional[str]`, но это не является **не обязательным**, вы не сможете вызвать функцию без параметра:

```Python
say_hi()  # Oh, no, this throws an error! 😱
```

Параметр `name` **всё ещё обязателен** (не *опциональный*), потому что у него не определено значение по умолчанию. Тем не менее, параметр `name` может принимать в качестве значения - `None`:

```Python
say_hi(name=None)  # This works, None is valid 🎉
```

Но хорошая новость в том, что при переходе на Python 3.10, вам не нужно будет беспокоиться об этом, вы сможете просто использовать `|` для определения допустимых типов:

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009c_py310.py!}
```

И тогда вам не нужно буде беспокоиться о таких названиях, как `Optional` и `Union`. 😎


#### Обобщённые ти́пы

Ти́пы, которые принимают другие ти́пы параметров внутри квадратных скобок, называют - **Обобщённые ти́пы** или **Generics**, например:

=== "Python 3.6 и выше"

    (*прим. перев. Предварительно вы должны импортировать эти значения из модуля 'typing'!)

    * `List`
    * `Tuple`
    * `Set`
    * `Dict`
    * `Union`
    * `Optional`
    * ...and others.

=== "Python 3.9 и выше"

    Вы можете использовать встроенные типы, как обощённые (с квадратными скобками и указанием типов внутри этих скобок):

    * `list`
    * `tuple`
    * `set`
    * `dict`

    И так же, как в Python 3.6, используя модуль `typing`:

    * `Union`
    * `Optional`
    * ...and others.

=== "Python 3.10 и выше"

    Вы можете использовать встроенные типы, как обощённые (с квадратными скобками и указанием типов внутри этих скобок):

    * `list`
    * `tuple`
    * `set`
    * `dict`

     И так же, как и в Python 3.6, используя модуль `typing`:

    * `Union`
    * `Optional` (то же, что и в Python 3.6)
    * ...и другие.

    В Python 3.10, как альтернативу использованию обобщённых типов `Union` и `Optional`, вы можете использовать <abbr title='also called "bitwise or operator", but that meaning is not relevant here'>вертикальную черту (`|`)</abbr> для объявления нескольких допустимых типов.

### Классы, как типы

Вы также можете объявить класс, как тип переменной.

Допустим, у вас есть класс `Person` с полем `name`:

```Python hl_lines="1-3"
{!../../../docs_src/python_types/tutorial010.py!}
```

Далее, в качестве парметра функции, вы объявляете переменную, у которой будет тип `Person`:

```Python hl_lines="6"
{!../../../docs_src/python_types/tutorial010.py!}
```

А затем опять получаете поддержку редактора:

<img src="/img/python-types/image06.png">


## Модели Pydantic

<a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic</a> является библиотекой Python для выполнения проверок данных.

Вы объявляете "структуру" данных, как классы с атрибутами.

И каждому атрибуту указываете тип.

Затем вы создаете экземпляр этого класса с некоторыми значениями и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

И вы получаете полную поддержку редактора для этого итогового объекта.

Пример взят из официальной документации Pydantic:

=== "Python 3.6 и выше"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011.py!}
    ```

=== "Python 3.9 и выше"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011_py39.py!}
    ```

=== "Python 3.10 и выше"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011_py310.py!}
    ```
!!! Информация
    Чтобы узнать больше о <a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic, прочитайте его документацию</a>.

**FastAPI** полностью основан на Pydantic.

## Аннотации типов в **FastAPI**

**FastAPI** использует преимущества аннотаций типов для выполнения определённых задач.

В **FastAPI** вы объявляете параметры с аннотациями типов и получаете:

* **Поддержку редактора**.
* **Проверки типов**.

...и **FastAPI** использует тот же механизм для:

* **Определения требований**: из параметров пути, параметров запроса, заголовков, зависимостей и т.д.
* **Преобразования данных**: из запроса к нужному типу.
* **Проверки данных**: приходящих с каждым запросом:
    * Генерации **автоматических ошибок**, возвращаемых клиенту, когда данные не являются корректными.
* **Документирования** API с использованием OpenAPI:
    * которое затем используется пользовательскими интерфейсами автоматической интерактивной документации.

Всё это может показаться абстрактным. Не волнуйтесь. Вы увидите всё это в действии в [Руководстве пользователя](tutorial/index.md){.internal-link target=_blank}.

Важно то, что при использовании стандартных типов Python в одном месте (вместо добавления дополнительных классов, декораторов и т.д.) **FastAPI** сделает за вас большую часть работы.

!!! Информация
    Если вы уже прошли всё руководство и вернулись, чтобы узнать больше о типах, хорошим источником является <a href="https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html" class="external-link" target="_blank">«шпаргалка» от `mypy`</a>.
