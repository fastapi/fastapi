# О HTTPS

Легко предположить, что HTTPS - это что-то, что "включено" или нет.

Но все гораздо сложнее, чем кажется.

!!! Подсказка
    Если вы торопитесь или вам все равно, читайте следующие разделы пошаговой инструкции по настройке развертывания с использованием различных технологий.

Чтобы **понять основы HTTPS** с точки зрения пользователя, изучите <a href="https://howhttps.works/ru/" class="external-link" target="_blank">https://howhttps.works/</a>.

Итак, **с точки зрения разработчика** есть несколько вещей, которые надо держать в уме, размышляя о HTTPS:

* При использовании протокола HTTPS, **сервер** должен **обладать "сертификатами"**, сгенерированными **третьей стороной**.
    * На самом деле, третья сторона **выдает** сертификаты, а не "генерирует".
* У сертификатов есть **срок действия**.
    * Он **истекает**.
    * После этого сертификаты необходимо **обновить**, **вновь получить** от третьей стороны.
* Шифрование соединения происходит на **TCP-уровне**.
    * Это на один уровень **ниже HTTP**.
    * Так что **сертификация и шифрование** выполняется **перед HTTP**.
* **TCP не знает о "доменах"**. Только об IP-адресах.
    * Информация **о конкретном запрашиваемом домене** содержится в **данных HTTP**.
* **HTTPS-сертификаты** "сертифицируют" **определенный домен**, но протокол и шифрование происходит на TCP-уровне, **не зная** с каким доменом ведется работа.
* **По умолчанию**, это означает, что вы можете иметь только **один HTTPS-сертификат на IP-адрес**.
    * Вне зависимости от того, насколько большой у вас сервер или насколько малы приложения, которые имеются на нем.
    * Несмортря на это, имеется **решение** данной проблемы.
* Существует **расширение** протокола **TLS** (того, что управляет шифрованием на TCP-уровне, перед HTTP), которое называется **<a href="https://ru.wikipedia.org/wiki/Server_Name_Indication" class="external-link" target="_blank"><abbr title="Индикация имени сервера">SNI</abbr></a>**.
    * Расширение SNI позволяет одному серверу (**с одним IP-адресом**) иметь **несколько HTTPS-сертификатов** и обслуживать **несколько HTTPS-доменов/приложений**.
    * Для работы SNI необходимо, чтобы **один** компонент (программа), запущенный на сервере и слушающий **публичный IP-адрес**, должен иметь доступ ко **всем HTTPS-сертификатам** на сервере.
* **После** установления защищенного соединения, в качестве протокола соединения все еще **используется HTTP**.
    * Данные **шифруются**, даже несмотря на то, что они посылаются с использованием **протокола HTTP**.

Нормальной практикой является ситуация, при которой **одна программа/HTTP-сервер**, запущенный на сервере (машине, хосте, и т.д.) и **управлениющий всеми частями HTTPS**: получение **зашифрованных HTTPS запросов**, отправка **расшифрованных HTTP запросов** конкретному HTTP приложению, запущенному на данном сервере (в нашем случае приложение **FastAPI**), прием **HTTP ответа** от приложения, **его шифрование** при помощи соответствующего **HTTPS сертификата** и его дальнейшая отправка обратно клиенту, используя **HTTPS**. Такой сервер зовется **<a href="https://en.wikipedia.org/wiki/TLS_termination_proxy" class="external-link" target="_blank">прокси-сервер завершения TLS</a>**.

Ниже представлены варианты, которые вы можете использовать как прокси-сервер завершения TLS:

* Traefik (может управлять обновлением сертификатов)
* Caddy (может управлять обновлением сертификатов)
* Nginx
* HAProxy

## Let's Encrypt

До создания Let's Encrypt, **HTTPS-сертификаты** продавались доверенными третьими сторонами.

Процесс получения сертификата был трудоемким, требовал много бумажной работы, а цена на сертификат была довольно высокой.

Затем был создан **<a href="https://letsencrypt.org/" class="external-link" target="_blank">Let's Encrypt</a>**.

Это проект Linux Foundation. Он обеспечиват автоматизированную выдачу **бесплатных HTTPS-сертификатов**. Данные сертификаты испольуют все стандартные криптографические средства обеспечения безопасности, с коротким периодом действия (около 3 месяцев), поэтому **безопасность данных сертификатов выше** из-за уменьшеного срока службы.

Домены надежно проверяются, а сертификаты автоматически генерируются. Также возможно автоматическое обновление данных сертификатов.

Основная идея - это автоматизировать получение и обновление сертификатов, чтобы у вас постоянно имелся **безопасный HTTPS, бесплатно и навсегда**.

## HTTPS для разработчиков

Это пошаговый пример того, как может выглядеть HTTPS API, в котором основное внимание будет обращено на идеи, важные для разработчика.

### Доменное имя

Все начинается с того, что вы **получаете** какое-то **доменное имя**. После, вы настраиваете его на DNS-сервере (возможно, того же облачного провайдера).

Вы, скорее всего, получите облачный сервер (виртуальную машину) или что-то подобное, и у него будет <abbr title="Он не изменяется">фиксированный</abbr> **публичный IP-адрес**.

В DNS-сервере (серверах) вам стоит настроить "`A-запись`", которая позволяет **вашему домену** указывать на публичный **IP-адрес вашего сервера**.

Вероятнее всего, вы сделаете это все один раз, при первичной настройке.

!!! Подсказка
    Часть "Доменное имя" объясняется намного раньше HTTPS, но поскольку все зависит от домена и IP-адреса, стоит упомянуть об этом здесь.

### DNS

Теперь давайте сосредоточимся на всех фактических частях HTTPS.

Во-первых, браузер проверяет с помощью **DNS-серверов**, какой **IP-адрес у домена**, в данном случае `someapp.example.com`.

DNS-сервера подскажут браузеру  какой конкретный **IP-адрес** использовать. Это будет публичный IP-адрес, используемый вашим сервером, который вы настроили в DNS-серверах.

<img src="/img/deployment/https/https01.svg">

### Начало TLS-рукопожатия

После этого, браузер будет взаимодействовать с данным IP-адресом на **443 порте** (порт HTTPS).

Первая часть взаимодействия это просто установление соединения мужду клиентом и сервером для согласования используемых криптографических ключей и т.д.

<img src="/img/deployment/https/https02.svg">

Взаимодействие между клиентом и сервером для установления TLS-соединения зовется **TLS-рукопожатие**.

### TLS с SNI расширением

**Только один процесс** на сервере может слушать определенный **порт** на определенном **IP-адресе**. Могут быть и другие процессы, слушающие на других портах тот же самый IP-адрес, но только один процесс для каждой комбинации IP-адреса и порта.

TLS (HTTPS) по умолчанию использует порт `443`. Так что, именно этот порт нам и нужен.

Так как только один процесс может слушать этот порт, этим процессом будет **прокси-сервер завершения TLS**.

У прокси-сервера завершения TLS будет доступ к одному или более **TLS сертификатам** (HTTPS сертификатам).

Испольуя **SNI расширение**, которое обсуждалось выше, прокси-сервер завершения TLS будет проверять какой из TLS (HTTPS) сертификатов он должен использовать для соединения, используя тот, что совпадает с доменом ожидаемым клиентом.

В этом случает, будет использован сертификат для `someapp.example.com`.

<img src="/img/deployment/https/https03.svg">

Клиент уже **доверяет** сущности, которая сгенерировала данный TLS сертификат (в этом случает Let's Encrypt, но мы обсудим это позже), так что он может **верифицировать**, что сертификат действителен.

Затем, используя сертификат, клиент и прокси-сервер завершения TLS **определяют способ шифрования** дальнейшего **TCP-соединение**. Этим заканчивается **TLS-рукопожатие**.

После этого, между клиентом и сервером устанавливается **зашифрованное TCP-соединение**, которое обеспечивает TLS. Это соединение используется для начала фактического **HTTP-соединения**.

В этом и заключается суть **HTTPS** - это просто **HTTP** внутри **защищенного TLS-соединения** вместо чистого (незашифрованного) TCP-соединения.

!!! Подсказка
    Обратите внимание, что шифрование соединения происходит на **TCP-уровне**, а не HTTP-уровне.

### HTTPS запрос

Теперь когда между клиентом и сервером (конкретно между браузером и прокси-сервером завершения TLS) установлено **зашифрованное TCP-соединение**, они могут начать **HTTP-коммуникацию**.

Итак, клиент шлет **HTTPS-запрос**. Это всего лишь обычный HTTP-запрос переданный через зашифрованное TLS-соединение.

<img src="/img/deployment/https/https04.svg">

### Расшифровка запроса

Прокси-сервер завершения TLS будет использовать выбранный способ шифрования для **расшифровки запроса**, и перенаправит **простой (расшифрованный) HTTP-запрос** процессу запущенного приложения (например процесс Uvicorn с запущенным приложением FastAPI).

<img src="/img/deployment/https/https05.svg">

### HTTP ответ

После обработки запроса приложение направит **простой (незашифрованный) HTTP-ответ** прокси-серверу завершения TLS.

<img src="/img/deployment/https/https06.svg">

### HTTPS ответ

Прокси-сервер завершения TLS **зашифрует ответ** с использованием выбранного способа шифрования (that started with the certificate for `someapp.example.com`), и отправит его обратно браузеру.

Далее, браузер удостоверится что ответ валиден, зашифрован правильным криптографическим ключом и т.д. Затем он **расшифровывает ответ** и обрабатывает его.

<img src="/img/deployment/https/https07.svg">

Клиент (браузер) будет знать, что ответ пришел от верного сервера, потому что будет использоваться криптография, о которой они предварительно договорились при помощи **HTTPS-сертификата**.

### Множественные приложения

На одном сервере (или серверах), может быть **множество приложений**, например, другие API программы или базы данных.

Только один процесс может обрабатывать определенный IP и порт (прокси-сервер завершения TLS в нашем случае), но другие приложения/процессы могут быть запущены на сервере (серверах), пока они не пытаются использовать одну и ту же **комбинацию публичного IP и порта**.

<img src="/img/deployment/https/https08.svg">

Таким образом, прокси-сервер завершения TLS может обслуживать HTTPS и сертификаты для **нескольких доменов**, для нескольких приложений и отправлять запросы в соответсвующие приложения для каждого случая.

### Обновление сертификата

В какой-то момент, срок действия любого сертификата **истечет** (примерно через 3 месяца после его получения).

После этого, другая программа (иногда это другая программа, иногда это может быть тот же прокси-сервер завершения TLS) свяжется с Let's Encrypt и обновит сертификат(ы).

<img src="/img/deployment/https/https.svg">

**TLS-сертификаты связаны с доменным именем**, а не с IP-адресом.

Итак, для обновления сертификата, программе обновления необходимо **доказать** проверяющему (Let's Encrypt), что она в самом деле **"владеет" и контролирует данный домен**.

Для этого, а также для удовлетворения различных потребностей приложений, существует несколько способов. Вот некоторые популярные способы:

* **Изменить некоторые записи DNS**.
    * Для этого программа обновления должна поддерживать API провайдера DNS, поэтому, в зависимости от используемого вами провайдера DNS, это может быть возможно, а может и нет.
* **Запуск в качестве сервера** (по крайней мере, на время получения сертификата) на публичном IP-адресе, связанном с доменом.
    * Как было сказано выше, только один процесс может слушать определенный IP и порт.
    * По этой причине удобно, когда прокси-сервер завершения TLS управляет процессом обновления сертификата.
    * С другой стороны, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.

Весь этот процесс обновления, во время обслуживания приложения, главная причина по которой важно иметь **отдельную систему управления HTTPS** с прокси-сервером завершения TLS вместо простого использования TLS-сертификатов с приложением напрямую сервером (например Uvicorn).

## Резюме

Использование **HTTPS** очень важно, даже скорее **критично важно** в большинстве случаев. Наибольшую пользу от HTTPS разработчик может получить лишь **понимая основные концепции** и как они работают.

Но после понимания основной информации, содержащейся в **HTTPS для разработчиков**, вы сможете с легкостью комбинировать и настраивать различные инструменты для помощи в управлении всем простым способом.

В следующих главах я покажу несколько конкретных примеров по настройке **HTTPS** для приложений **FastAPI**. 🔒
