# Особенности

## Особенности FastAPI

**FastAPI** имеет следующие преимущества:

### Основан на открытых стандартах

* <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank"><strong>OpenAPI</strong></a> для создания API, включая объявления <abbr title="также известных как HTTP методы, такие как POST, GET, PUT, DELETE">операций</abbr> <abbr title="также известных как: эндпоинты, роутеры">путей</abbr>, параметров, тел запроса, безопасности, и т.д.
* Автоматическая документация моделей данных используя <a href="https://json-schema.org/" class="external-link" target="_blank"><strong>схему JSON</strong></a> (поскольку сам OpenAPI основан на схеме JSON).
* Спроектирован, после тщательного изучения, в соответствии с этими стандартами. Вместо запоздалого слоя сверху.
* Это также позволяет использовать автоматическую **генерацию клиентского кода** на многих языках.

### Автоматическая документацию

Интерактивная документация по API и изучение пользовательских веб-интерфейсов. Поскольку фреймворк основан на OpenAPI, существует несколько вариантов, 2 из которых включены по умолчанию.

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank"><strong>Swagger UI</strong></a>, с интерактивным исследованием, вызовом и тестированием вашего API прямо из браузера.

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* Альтернативная документация API с использованием <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank"><strong>ReDoc</strong></a>.

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Только современный Python

Все это основано на стандартных объявлениях **типов Python 3.6** (спасибо Pydantic). Нет нового синтаксиса для изучения. Только стандартный современный Python.

Если вам нужно 2-х минутное освежение знаний о том, как использовать типы Python (даже если вы не используете FastAPI), ознакомьтесь с кратким руководством: [Типы Python](python-types.md){.internal-link target=_blank}.

Вы пишете стандартный Python с типами:

```Python
from datetime import date

from pydantic import BaseModel

# Объявите переменную как строку
# и получите помощь редактора внутри функции
def main(user_id: str):
    return user_id


# Модель Pydantic
class User(BaseModel):
    id: int
    name: str
    joined: date
```

Затем это можно использовать как:

```Python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```

!!! Информация
    `**second_user_data` означает:

    Передайте ключи и значения словаря `second_user_data` непосредственно в качестве аргументов ключ-значение, что эквивалентно: `User(id=4, name="Mary", join="2018-11-30")`

### Помощь редактора

Весь фреймворк был спроектирован так, чтобы быть простым и интуитивно понятным в использовании, все решения были протестированы в нескольких редакторах еще до начала разработки, чтобы обеспечить наилучшие впечатления от разработки.

В последнем опросе разработчиков Python было ясно, <a href="https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features" class="external-link" target="_blank">что наиболее часто используемой функцией является "автодополнение"</a>.

Весь **FastAPI** основан на том, чтобы удовлетворять этому. Автодополнение работает везде.

Вам редко придется возвращаться к документации.

Вот как ваш редактор может вам помочь:

* в <a href="https://code.visualstudio.com/" class="external-link" target="_blank">Visual Studio Code</a>:

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

* в <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a>:

![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)

Вы получите завершение кода, которое раньше даже считалось невозможным. Как, например, ключ `price` внутри тела JSON (который мог быть вложенным), полученный из запроса.

Больше не придётся ошибаться при вводе названий ключей, переключаться между документацией или прокручивать код вверх и вниз, чтобы понять, использовали ли вы, наконец, `username` или `user_name`.

### Краткость

Он имеет разумные **значения по умолчанию** и опциональные настройки везде. Все параметры могут быть точно настроены, чтобы делать то, что вам нужно, и определять нужный вам API.

По умолчанию все это **"просто работает"**.

### Валидация

* Валидация для большинства (или всех?) **типов данных** Python, включая:
    * Объекты JSON (`dict`).
    * Массив JSON (`list`) с определёнными типами объектов.
    * Строковые (`str`) поля, определяющие минимальную и максимальную длину.
    * Числа (`int`, `float`) с минимальными и максимальными значениями, и т.д.

* Валидация для более экзотических типов, таких как:
    * URL.
    * Email.
    * UUID.
    * ...и других.

Вся валидация выполняется надежным и хорошо зарекомендовавшим себя **Pydantic**.

### Безопасность и аутентификация

Безопасность и аутентификация интегрированы. Без каких-либо компромиссов с базами данных или моделями данных.

Все схемы безопасности, определенные в OpenAPI, в том числе:

* HTTP Basic.
* **OAuth2** (также с использованием **токенов JWT**). Ознакомьтесь с руководством на странице [OAuth2 с использованием JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.
* Ключи API в:
    * Заголовках.
    * Параметрах запроса.
    * Cookie, и т.д.

Плюс все функции безопасности из Starlette (включая **сеансовые(сессионные) Cookie**).

Все они созданы как повторно используемые инструменты и компоненты, которые легко интегрируются с вашими системами, хранилищами данных, реляционными и NoSQL базами данных и т.д.

### Внедрение зависимости

FastAPI включает чрезвычайно простую в использовании, но чрезвычайно мощную систему <abbr title='также известные как "компоненты", "ресурсы", "сервисы", "провайдеры"'><strong>Внедрение зависимости</strong></abbr>.

* Даже зависимости могут иметь зависимости, создавая иерархию или **"граф" зависимостей**.
* Всё **автоматически обрабатывается** фреймворком.
* Все зависимости могут требовать данные из запросов, **дополнять ограничения для операций путей** и автоматическую документацию.
* **Автоматическая валидация** даже для параметров *операций путей*, определенных в зависимостях.
* Поддержка сложных систем аутентификации пользователей, **подключений к базе данных** и т.д.
* **Нет компромиссов** для баз данных, фронтенда и т.д. Но в то же время простая интеграция с ними.

### Неограниченное количество "плагинов"

Или по-другому, в них нет необходимости, импортируйте и используйте нужный вам код.

Любая интеграция спроектирована так, чтобы быть настолько простой в использовании (с зависимостями), что вы можете создать "плагин" для своего приложения в 2 строчки кода, используя ту же структуру и синтаксис, которые используются для ваших *операций путей*.

### Протестировано

* 100% <abbr title="Объем кода, который автоматически тестируется">покрытие тестами</abbr>.
* 100% кодовая база с <abbr title="Аннотации типов Python, с этим ваш редактор и внешние инструменты смогут дать вам лучшую поддержку">аннотациями типов</abbr>.
* Используется в производственных приложениях.

## Особенности Starlette

**FastAPI** полностью совместим с (и основан на) <a href="https://www.starlette.io/" class="external-link" target="_blank"><strong>Starlette</strong></a>. Таким образом, любой дополнительный код Starlette, который у вас есть, также будет работать.

`FastAPI` на самом деле является подклассом `Starlette`. Итак, если вы уже знаете или используете Starlette, большая часть функций будет работать так же.

С **FastAPI** вы получаете все функции **Starlette** (поскольку FastAPI это просто Starlette на стероидах):

* Действительно впечатляющая производительность. Это <a href="https://github.com/encode/starlette#performance" class="external-link" target="_blank">один из самых быстрых доступных Python фреймворков, по производительности не уступающий **NodeJS** и **Go**</a>.
* Поддержка **WebSocket**.
* Выполнение фоновых задач.
* События запуска и выключения.
* Тестовый клиент построеный на `requests`.
* **CORS**, GZip, статические файлы, потоковые ответы.
* Поддержка **Сеансов(Сессий) и Cookie**.
* 100% покрытие тестами.
* 100% кодовая база с аннотациями типов.

## Особенности Pydantic

**FastAPI** полностью совместим с (и основан на) <a href="https://pydantic-docs.helpmanual.io" class="external-link" target="_blank"><strong>Pydantic</strong></a>. Таким образом, любой дополнительный код Pydantic, который у вас есть, также будет работать.

Включая внешние библиотеки, также основанные на Pydantic, такие как <abbr title="Object-Relational Mapper">ORM</abbr>s, <abbr title="Object-Document Mapper">ODM</abbr>s для баз данных.

Это также означает, что во многих случаях вы можете передать тот же объект, который вы получаете из запроса, **непосредственно в базу данных**, так как все проверяется автоматически.

То же самое работает и в обратную сторону: во многих случаях вы можете просто передать объект, полученный из базы данных, **непосредственно клиенту**.

С **FastAPI** вы получаете все функции **Pydantic** (поскольку FastAPI основан на Pydantic для обработки всех данных):

* **Не ломайте мозг**:
    * Нет нового микроязыка определения схемы для изучения.
    * Если вы знаете типы Python, вы знаете, как использовать Pydantic.
* Прекрасно сочетается с вашими **<abbr title="Интегрированной средой разработки, похожей на редактор кода">IDE</abbr>/<abbr title="Программа, проверяющая наличие ошибок в коде">линтером</abbr>/мозгом**:
    * Потому что структуры данных pydantic — это просто экземпляры классов, которые вы определяете; автозавершение, линтинг, mypy и ваша интуиция должны работать правильно с вашими валидированными данными.
* **Скорость**:
    * в <a href="https://pydantic-docs.helpmanual.io/benchmarks/" class="external-link" target="_blank">тестах производительности</a> Pydantic работает быстрее всех остальных протестированных библиотек.
* Валидация **сложных структур**:
    * Используйте иерархические моделей Pydantic, Python `typing`, `List`, `Dict` и т.д.
    * А валидаторы позволят четко и легко определять, проверять и документировать сложные схемы данных в виде схемы JSON.
    * У вас могут быть глубоко **вложенные объекты JSON**, и все они должны быть провалидированны и аннотированы.
* **Расширяемость**:
    * Pydantic позволяет определять пользовательские типы данных, или расширять валидацию с помощью методов, обёрнутых декоратором validator.
* 100% покрытие тестами.
