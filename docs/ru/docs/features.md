# Возможности

## FastAPI возможности

**FastAPI** дает вам следующее:

### Использование открытых стандартов

* <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank"><strong>OpenAPI</strong></a> для создания API, включая объявления <abbr title="также известные как ендпоинты, маршруты">путей</abbr> <abbr title="также известных как HTTP-методы POST, GET, PUT, DELETE">операций</abbr>, параметров, тела запросов, безопасности и т.д.
* Автоматическое документирование моделей данных с <a href="https://json-schema.org/" class="external-link" target="_blank"><strong>JSON Schema</strong></a> (т.к. OpenAPI основан на JSON Schema).
* Проектирование вокруг этих стандартов после тщательного изучения.
* Автоматическая **генерация кода клиента** на многих языках программирования.

### Автоматически генерируемая документация

Интерактивная документация и пользовательский интерфейс для исследования API. Так как фреймворк основан на OpenAPI, эти две возможности включены по умолчанию.

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank"><strong>Swagger UI</strong></a>, с интерактивным исследованием, вызовом и тестированием вашего API прямо в браузере.

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* Альтернативная API-документация с <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank"><strong>ReDoc</strong></a>.

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Просто Современный Python

Все это основано на стандартных объявлениях **типов Python 3.6** (благодаря Pydantic). Никакого нового синтаксиса для изучения. Просто стандартный современный Python.

Если вам необходима пара минут, чтобы освежить в памяти, как использовать аннотации типов Python (даже если вы не используете FastAPI), ознакомьтесь с кратким руководством: [Python Types](python-types.md){.internal-link target=_blank}.

Вы пишете стандартный Python-код с типами:

```Python
from typing import List, Dict
from datetime import date

from pydantic import BaseModel

# Объявите переменную как str
# и получите поддержку редактора внутри функции
def main(user_id: str):
    return user_id


# Pydantic-модель
class User(BaseModel):
    id: int
    name: str
    joined: date
```

Затем это может быть использовано следующим образом:

```Python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```

!!! info
    `**second_user_data` означает:

    Передать ключи и значения словаря `second_user_data` напрямую в качестве аргументов типа ключ-значение, что эквивалентно варианту `User(id=4, name="Mary", joined="2018-11-30")`

### Поддержка редакторов

Весь фреймворк был спроектирован таким образом, чтобы быть простым и интуитивным в использовании, все решения были протестированы на множестве редакторов даже перед начальной разработкой, чтобы гарантировать лучший опыт разработки.

В опросе Python-разработчиков за 2017 год было ясно, что <a href="https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features" class="external-link" target="_blank">наиболее часто используемая функция - "автодополнение"</a>.

Весь **FastAPI**-фреймворк основан на том, чтобы достичь этого. Автодополнение работает везде.

Вам редко придется возвращаться к документации.

Вот как ваш редактор может вам помочь:

* в <a href="https://code.visualstudio.com/" class="external-link" target="_blank">Visual Studio Code</a>:

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

* в <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a>:

![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)

Вы получите автодополнение в коде, которое раньше даже считали невозможным. Как, например, ключ `price` внутри JSON-тела (который мог быть вложенным), который приходит из запроса.

Больше не придется вводить неправильные названия ключей, переключаться между документами или скроллить, чтобы узнать, использовали ли вы `username` или `user_name`.

### Краткость

Имеются разумные **настройки по умолчанию** для всего с дополнительными опциями повсюду. Все параметры могут быть настроены таким образом, чтобы делать то, что вам нужно, и определять API, который вам нужен.

Но по умолчанию все это **"просто работает"**.

### Валидация

* Валидация для большинства (или всех?) **типов данных** в Python, включая:
    * JSON-объекты (`dict`).
    * JSON-массив (`list`), определяющий типы элементов.
    * Строковые (`str`) поля, определяющие максимальную и минимальную длину.
    * Числа (`int`, `float`) с минимальными и максимальными значениями, и т.д.

* Валидация для более экзотических типов:
    * URL.
    * Email.
    * UUID.
    * ...и др.

Вся валидация выполняется хорошо зарекомендовавшим себя и надежным **Pydantic**.

### Безопасность и аутентификация

Безопасность и аутентификация интегрированы. Без каких-либо компромиссов с базами данных или моделями данных.

Все схемы безопасности определены в OpenAPI, включая:

* HTTP Basic.
* **OAuth2** (также с **JWT-токенами**). Проверьте руководство [OAuth2 с JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.
* API-ключи в:
    * заголовках.
    * Query-параметрах.
    * Cookies, и т.д.

А также все возможности, связанные с безопасностью, от Starlette (включая **session cookies**).

Все они созданы как инструменты и компоненты для дальнейшего переиспользования, которые легко интегрируются с вашими системами, хранилищами данных, реляционными и NoSQL базами данных, и т.д.

### Внедрение зависимостей (Dependency Injection)

FastAPI включает в себя чрезвычайно простую в использовании, но при этом чрезвычайно мощную систему для <abbr title='также известных как "компоненты", "ресурсы", "сервисы", "провайдеры"'><strong>внедрения зависимостей (Dependency Injection)</strong></abbr>.

* Даже зависимости могут иметь зависимости, создавая иерархию или **"граф" зависимостей**.
* Все они **автоматически обрабатываются** фреймворком.
* Все зависимости могут требовать данные из запросов и **дополнять операцию пути** ограничениями и автоматической документацией.
* **Автоматическая валидация** даже для параметров *операции пути*, определенных в зависимостях.
* Поддержка для сложных систем аутентификации пользователей, **подключений баз данных**, и т.д.
* **Нет компромиссов** с базами данных, фронтендами, и т.д. Но простая интеграция с всеми из них.

### Неограниченные "плагины"

Другими словами, в них нет необходимости, просто импортируйте и используйте код, который вам необходим.

Любая интеграция спроектирована таким образом, чтобы быть настолько простой в использовании (с зависимостями), что вы можете создать «плагин» для своего приложения в пару строк кода, используя ту же структуру и синтаксис, что и для ваших *операций с путями*.

### Протестированный

* 100% <abbr title="Количество автоматически протестированного кода">покрытие тестами</abbr>.
* 100%-<abbr title="Аннотации Python-типов, с которыми ваш редактор и другие инструменты могут предоставить вам лучшую поддержку">покрытая аннотациями типов</abbr> кодовая база.
* Используется в реальных приложениях.

## Starlette возможности

**FastAPI** является полностью совместимым со (и основан на) <a href="https://www.starlette.io/" class="external-link" target="_blank"><strong>Starlette</strong></a>. Поэтому любой дополнительный Starlette-код, который у вас есть, будет также работать.

FastAPI на самом деле является подклассом Starlette. То есть, если вы уже знаете или используете Starlette, большая часть возможностей будет работать точно так же.

С **FastAPI** вы получите все возможности **Starlette** (так как FastAPI является просто Starlette на стероидах):

* Серьезно впечатляющая производительность. Это <a href="https://github.com/encode/starlette#performance" class="external-link" target="_blank">один из самых быстрых доступных Python-фреймворков, наряду с **NodeJS** и **Go**</a>.
* Поддержка **WebSocket**.
* Поддержка **GraphQL**.
* Фоновые задачи в процессе.
* События для запуска и выключения приложения.
* Клиент для тестирования, основанный на `requests`.
* **CORS**, GZip, Static Files, Streaming responses.
* Поддержка **Session и Cookie**.
* 100% покрытие тестами.
* 100% покрытая аннотациями типов кодовая база.

## Pydantic возможности

**FastAPI** является полностью совместимым с (и основан на) <a href="https://pydantic-docs.helpmanual.io" class="external-link" target="_blank"><strong>Pydantic</strong></a>. Поэтому любой дополнительный Pydantic-код, который у вас есть, будет также работать.

Включая внешние библиотеки, которые также основаны на Pydantic, как, к примеру, <abbr title="Object-Relational Mapper">ORM</abbr>, <abbr title="Object-Document Mapper">ODM</abbr> для баз данных.

Это также означает, что во многих случаях вы можете передать тот же объект, который вы получаете из запроса, **напрямую в базу данных**, т.к. все проверяется автоматически.

То же самое применимо и наоборот: во многих случаях вы можете просто передать объект, получаемый из базы данных, **напрямую клиенту**.

С **FastAPI** вы получите все возможности **Pydantic** (так как FastAPI основан на Pydantic для всех обработок данных):

* **Нет выноса мозга**:
    * Нет нового микроязыка определения схемы для изучения.
    * Если вы знаете Python-типы, вы знаете, как использовать Pydantic.
* Отличная интеграция с вашим **<abbr title="Интегрированная среда разработки (Integrated Development Environment), похожая на редактор кода">IDE</abbr>/<abbr title="Программа, которая проверяет ошибки кода">линтером</abbr>/мозгом**:
    * Потому как структуры данных pydantic являются просто экземплярами определенных вами классов; автодополнение, линтинг, mypy и ваша интуиция должны правильно работать с вашими проверенными данными.
* **Быстроту**:
    * по <a href="https://pydantic-docs.helpmanual.io/#benchmarks-tag" class="external-link" target="_blank">замерам</a> Pydantic быстрее всех других протестированных библиотек.
* Валидацию **сложных структур**:
    * Использование иерархических Pydantic-моделей, `List` и `Dict` из Python-модуля `typing`, и т.д.
    * И валидаторы позволяют четко и легко определять сложные схемы данных, проверять и документировать их по спецификации JSON Schema. 
    * У вас могут быть глубоко **вложенные JSON-объекты** все они будут провалидированы и иметь аннотации.
* **Расширяемость**:
    * Pydantic позволяет определять пользовательские типы данных, или вы можете расширить валидацию с помощью методов в модели с `validator` декоратором.
* 100% покрытие тестами.
