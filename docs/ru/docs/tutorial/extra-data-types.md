# Дополнительные типы данных

До сих пор вы использовали простые типы данных, такие как:

* `int`
* `float`
* `str`
* `bool`

Но вы также можете использовать и более сложные типы.

При этом у вас останутся те же возможности , что и до сих пор:

* Отличная поддержка редактора.
* Преобразование данных из входящих запросов.
* Преобразование данных для ответа.
* Валидация данных.
* Автоматическая аннотация и документация.

## Другие типы данных

Ниже перечислены некоторые из дополнительных типов данных, которые вы можете использовать:

* `UUID`:
    * Стандартный "Универсальный уникальный идентификатор", используемый в качестве идентификатора во многих базах данных и системах.
    * В запросах и ответах будет представлен как `str`.
* `datetime.datetime`:
    * Встроенный в Python `datetime.datetime`.
    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `2008-09-15T15:53:00+05:00`.
* `datetime.date`:
    * Встроенный в Python `datetime.date`.
    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `2008-09-15`.
* `datetime.time`:
    * Встроенный в Python `datetime.time`.
    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `14:23:55.003`.
* `datetime.timedelta`:
    * Встроенный в Python `datetime.timedelta`.
    * В запросах и ответах будет представлен в виде общего количества секунд типа `float`.
    * Pydantic также позволяет представить его как "Кодировку разницы во времени ISO 8601", <a href="https://pydantic-docs.helpmanual.io/usage/exporting_models/#json_encoders" class="external-link" target="_blank">см. документацию для получения дополнительной информации</a>.
* `frozenset`:
    * В запросах и ответах обрабатывается так же, как и `set`:
        * В запросах будет прочитан список, исключены дубликаты и преобразован в `set`.
        * В ответах `set` будет преобразован в `list`.
        * В сгенерированной схеме будет указано, что значения `set` уникальны (с помощью JSON-схемы `uniqueItems`).
* `bytes`:
    * Встроенный в Python `bytes`.
    * В запросах и ответах будет рассматриваться как `str`.
    * В сгенерированной схеме будет указано, что это `str` в формате `binary`.
* `Decimal`:
    * Встроенный в Python `Decimal`.
    * В запросах и ответах обрабатывается так же, как и `float`.
* Вы можете проверить все допустимые типы данных pydantic здесь: <a href="https://pydantic-docs.helpmanual.io/usage/types" class="external-link" target="_blank">Типы данных Pydantic</a>.

## Пример

Вот пример *операции пути* с параметрами, который демонстрирует некоторые из вышеперечисленных типов.

=== "Python 3.8 и выше"

    ```Python hl_lines="1  3  12-16"
    {!> ../../../docs_src/extra_data_types/tutorial001.py!}
    ```

=== "Python 3.10 и выше"

    ```Python hl_lines="1  2  11-15"
    {!> ../../../docs_src/extra_data_types/tutorial001_py310.py!}
    ```

Обратите внимание, что параметры внутри функции имеют свой естественный тип данных, и вы, например, можете выполнять обычные манипуляции с датами, такие как:

=== "Python 3.8 и выше"

    ```Python hl_lines="18-19"
    {!> ../../../docs_src/extra_data_types/tutorial001.py!}
    ```

=== "Python 3.10 и выше"

    ```Python hl_lines="17-18"
    {!> ../../../docs_src/extra_data_types/tutorial001_py310.py!}
    ```
