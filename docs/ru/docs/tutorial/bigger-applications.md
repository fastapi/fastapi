# Большие Приложения - Увеличиваем количество файлов

Если Вы создаете приложение или веб API, то в редких случаях Вы сможете написать весь код в одном файле.

**FastAPI** предлагает к использованию удобный инструмент для гибкого структурирования файлов и директорий приложения по мере его
расширения

!!! info
    Если Вы пришли из Flask'а, этот инструмент будет эквивалентом Flask Blueprints.

## Пример файловой структуры

Представим, что у Вас есть следующая структура файлов:

```
.
├── app
│   ├── __init__.py
│   ├── main.py
│   ├── dependencies.py
│   └── routers
│   │   ├── __init__.py
│   │   ├── items.py
│   │   └── users.py
│   └── internal
│       ├── __init__.py
│       └── admin.py
```

!!! tip
    Здесь несколько файлов `__init__.py`: один  в каждой директории или поддиректории.
    Это то, что позволяет импортировать код из одного файла в другой.
	Например, в `app/main.py`  у Вас будет строка напримере следующей:

    ```
    from app.routers import items
    ```

* Директория `app` содержит в себе все. И она содержит в себе пустой файл `app/__init__.py`, это и называется "Python пакетом" (коллекцией "Python модулей"): `app`. 
* Она содержит файл `app/main.py`. Так как он находится внутри Python пакета (директории с файлом `__init__.py`), то он является "модулем" этого пакета: `app.main`.
* Так же здесь есть файл `app/dependencies.py`, так же, как и `app/main.py`, является "модулем": `app.dependencies`.
* Здесь находится поддиректория `app/routers` с еще одним файлов `__init__.py`, поэтому он будет называться "Python подпакетом": `app.routers`.
* Файл `app/routers/items.py` находится внутри пакета `app/routers/`, является подмодулем: `app.routers.items`.
* Тоже самое с файлом `app/routers/users.py`, это еще один подмодуль `app.routers.users`. 
* Здесь так же есть поддиректория `app/internal/` с еще одним файлом `__init__.py`, поэтому это еще один "Python подпакет": `app.internal`.
* И файл `app/internal/admin.py` является еще одним подмодулем: `app.internal.admin`.

<img src="/img/tutorial/bigger-applications/package.svg">

Та же самая файловая структура с комментариями:
```
.
├── app                  # "app" является Python пакетом
│   ├── __init__.py      # этот файл делает "app" директорию  "Python пакетом"
│   ├── main.py          # "main" модуль, пример использования - import app.main
│   ├── dependencies.py  # "dependencies" модуль, пример использования - import app.dependencies
│   └── routers          # "routers" является "Python подпакетом"
│   │   ├── __init__.py  # делает "routers" директорию "Python подпакетом"
│   │   ├── items.py     # "items" подмодуль, пример использования - import app.routers.items
│   │   └── users.py     # "users" подмодуль, пример использования - import app.routers.users
│   └── internal         # "internal" директория является "Python подпакетом"
│       ├── __init__.py  # делает "internal" директорию "Python подпакетом"
│       └── admin.py     # "admin" подмодуль, пример использования - import app.internal.admin
```

## `APIRouter`

Давайте скажем, что файл, задачей которого является навигация пользователей, является подмодулем в файле `/app/routers/users.py`. 

Вы хотите, что бы у Вас были *операции над url путями* `path operations`, относящиеся к Вашим пользователем, которые будут отделены от остального кода, что бы держать его организованным

Но они до сих пор являются частью того же **FastAPI** приложения/веб API (это часть того же "Python пакета").

Вы можете создать эти *операции над url путями* `path operations` для того модуля, используя `APIRouter`.

### Импортирование `APIRouter`

Вы импортируете его и создаете "экземпляр" тем же способ, что и с классом `FastAPI`;

```Python hl_lines="1  3"
{!../../../docs_src/bigger_applications/app/routers/users.py!}
```

### *Операции над url путями* `path operations` c `APIRouter`

И затем Вы используете его для определения Ваших *операций над url путями*

Используйте тот же самый способ, который Вы бы использовали для `FastAPI` класса:

```Python hl_lines="6  11  16"
{!../../../docs_src/bigger_applications/app/routers/users.py!}
```

Вы можете додумать, что `APIRouter` является "мини `FastAPi`" классом.

Все теже опции доступны и поддерживаются.

All the same `parameters`, `responses`, `dependencies`, `tags`, etc.
Все те же параметры `parameters`, ответы  `responses`, зависимости `dependencies`, тэги `tags`и т.д.

!!! tip
	В этом примере, переменная называется `router`, но Вы можете назвать ее как угодно

Мы собираемся внести этот `APIRouter` в основное приложение `FastAPI`, но для начала, давайте проверим, есть ли какие-либо зависимости или уже существующий `APIRouter`

## Зависимости

Мы видим, что нам понадобятся некоторые зависимости, используемые в некоторых местах приложения.

Поэтому мы поместим их в наш файл зависимостей `dependencies`, который является модулем (`app/dependencies.py`).

Сейчас мы будем использовать простую зависимость, что бы прочитать кастомный `X-Token` заголовок:

```Python hl_lines="1  4-6"
{!../../../docs_src/bigger_applications/app/dependencies.py!}
```

!!! tip
    Мы используем уже открытый заголовок для упрощения этого примера
    Но в реальных примерах Вы получите лучшие результаты, используя интегрированные [Инструменты безопасности](./security/index.md){internal-link target=_blank}. 
		
## Еще один модуль с `APIRouter`

Давайте скажем, что у Вас есть конечные точки, целью которых является обработка предметов "items" из Вашего приложения в модуле `app/routers/items.py`. 

У Вас есть *операции над url путями* для:

* `/items/`
* `/items/{item_id}`

Это таже самая структура как и с `app/routers/users.py`. 

Но мы хотим быть умнее и упростить немного код.

Мы знаем, что все *операции над url путями* `path operations` в этом модуле имеют одни и теже атрибуты:

* Путь `prefix`: `/items`.
* Тэги `tags`: (Только один тэг: `items`).
* Экстра ответы: `responses`.
* Зависимости `dependencies`: всем им нужен та самая `X-Token` зависимость, что мы создали.

Так, вместо добавления всех этих атрибутов к каждой *операцией над url путем* `path operations`, мы можем легко добавить их в `APIRouter`.

```Python hl_lines="5-10  16  21"
{!../../../docs_src/bigger_applications/app/routers/items.py!}
```

Так как путь для каждой *операцией над url путем* `path operations` должен начинаться с `/`, как в:

```Python hl_lines="1"
@router.get("/{item_id}")
async def read_item(item_id: str):
    ...
```

...префикс не должен содержать в себе финальный слэш `/`.

Поэтому, префиксом в этом случае является `/items`.

Мы также можем добавить список тэгов `tags` и экстра ответы `responses`, которые будут применены для всех операций над url путями `path operations`, вложенные в этот роутер (обработчик путей).

И сейчас мы можем добавить список зависимостей `dependencies`, что будет добавлен ко всем *операциям над url путями* `path operations` в роутере и будут исполнены/исправлены для каждого запроса, которым он будет обеспечен.

!!! tip
	Более того, больше информации о [зависимости в *декораторе операциии над url путем*](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, ни единое значение не будет передано в Вашу *функцию операции над url путем*. 

Конечный ресультат тех путей предметов выглядят на данный момент так:

* `/items/`
* `/items/{item_id}`

...как мы и представляли

* Они будут помечены списком тэгов, который содержит в себе одну строку предметов `"items"`.
	* Эти "тэги" особенно используются для автоматических интерактивных систем документов (используя OpenAPI).
* Все из них будут внесены в преопределенные ответы `responses`.
* Все эти *операции над путями* будут иметь список зависимостей `dependencies` оцененные/исполенные перед ними.
	* Если Вы также определили зависимости в специфичной *операцией над url путем*, **они будут исполнены тоже**.
	* Зависимости роутера исполняются первыми, затем [зависимости `dependencies` в декораторе](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, и затем нормальные зависимости параметров.
	* Вы можете добавить [зависимости `Безопасности` с `объемом работ`](../advanced/security/oauth2-scopes.md){.internal-link target=_blank}.*

!!! tip
    Имея `зависимости` в `APIRouter` может быть полезно, например, для требования аутентификации для всей группы *операций над url путями* `path operations`. Даже, если зависимости не добавлены индивидуально для каждой из них.

!!! check
    Префикс `prefix`, тэги `tags`, ответы `responses`, и зависимости `dependencies` - все эти параметры (как и во многих других случаях) просто являются особенностью **FastApi** для избежания дубликаций кода.
    
### Импортирование зависимостей

Этот код живет в модуле `app.routers.items`, файла `app/routers/items.py`.

И нам нужно получить функцию зависимости из модуля `app.dependencies`, файла `app/dependencies.py`.

Так мы используем родственное импортирование с помощью `..` для зависимостей:

```Python hl_lines="3"
{!../../../docs_src/bigger_applications/app/routers/items.py!}
```

#### Как родственное импортирование работает

!!! tip
    Если Вы знаете идеально, как работает импортирование, преступите к следующей секции ниже.

Одна точка `.`, как в 
```Python
from .dependencies import get_token_header
```

будет значить следующее:

* Начинаем в том же пакете, что этот модуль (файл `app/routers/items.py`) находится в (директории `app/routers`)...
* Находим модуль зависимостей `dependencies` (воображаемый файл в `app/routers/dependencies.py`)...
* И из него, импортируем функцию `get_token_header`.

Но тот файл не существует, наша зависимость в файле в `app/dependencies.py`

Запомните, как наша структура `app/file` выглядит:

<img src="/img/tutorial/bigger-applications/package.svg">

---

Две точки `..`, как в:

```Python
from ..dependencies import get_token_header
```

будут значить следующее:

* Начинаем в том же пакете, что и в этом модуле (файл `app/routers/items.py`) находится в (директории `app/routers/`)...
* Идем в родительский пакет (директория `app/`)...
* И там, найдем модуль зависимостей `dependencies` (файл в `app/dependencies.py`)...
* И из него, импортируем функцию `get_token_header`.

Работает идеально! 🎉

---

Тем же образом, если бы использовали три точки `...`, как в:
```Python
from ...dependencies import get_token_header
```

то это значило бы следующее:

* Начинаем в этом же пакете этого модуля (файл `app/routers/items.py`) находится в (директории `app/routers/')...
* Идем в родительский пакет (директория `app/`)...
* Затем идем к родителю этого пакета (здесь нет родительского пакета, `app` является верхним уровнем 😱)...
* И там, находим модуль зависимостей `dependencies` (файл в `app/dependencies.py`)...
* И из него, импортиурем функцию получения заголовка токена `get_token_header`.

Это будет относится к некоторому пакету над `app/`, со своим файлом `__init__.py`, например, но мы не хотим этого. Если это произойдетФ, то будет ошибка в нашем примере. 🚨 

Но сейчас Вы должны знать, как это работает, так Вы сможете использовать родственное импортирование в Ваших собственных приложениях без разницы, насколько они комплексны. 🤓

### ДОбавим несколько кастомных тэгов `tags`,  ответов `responses`, и зависимостей `dependencies`.

Мы не добавляем префикс предметов`items` ни с тэгами `tags=["items"] для каждой *операцией над url путем*`, потому что мы добавили их в `APIRouter`.

Но мы можем до сих пор добавить _more_ тэгов `tags`, что будут применены к специфичной *операцией над url путем*, и так же к некоторым экстра ответам `responses`, специфичным к тем *операциям над url путями:

```Python hl_lines="30-31"
{!../../../docs_src/bigger_applications/app/routers/items.py!}
```

!!! tip
	Эта последняя операция над url путем будет иметь комбинацию тэгов: `["items", "custom"]`.
	И она будет иметь оба ответа в документации, одна для `404` и одна для `403`.

## Основной файл `FastAPI`

Сейчас, давайте посмотрим на модуль в `app/main.py`.

Здесь, где Вы импортируете и используете класс `FastAPI`. 

Это будет основным файлом в Вашим приложении, которое будет сочетать все вместе.

И большинство логики будет сейчас жить в нашем специфичном модуле, основной файл же будет достаточно простым.

### Импортирование `FastAPI`

Вы импортируете и создаете `FastAPI` класс как обычно.

И мы можем даже сделать огласку [глобальных зависимостей](dependencies/global-dependencies.md){.internal-link target=_blank}, что будет скомбинировано с зависимостью для каждого `APIRouter`:

```Python hl_lines="1  3  7"
{!../../../docs_src/bigger_applications/app/main.py!}
```

### Импортирование `APIRouter`

Сечас мы импортируем остальные подмодули, которые имею `APIRouter`ы:

```Python hl_lines="5"
{!../../../docs_src/bigger_applications/app/main.py!}
```

Как и файлы `app/routers/users.py` и `app/routers/items.py` являются подмодулями, что являются часть одних и тех же Python пакетов `app`, мы можем использовать одну точку `.` для их импортирования, используя "родственные отношения".

### Как импортирование работает

Секция:

```Python
from .routers import items, users
```

Значит:

* Начинаем в том же пакете этого модуля (файл `app/main.py`) находится в (директории `app/')...
* Ищем подпакет роутеров 'routers' (директория в `app/routers/`)...
* И из него, импортирует подмодуль предметов `items` (файл в `app/routers/items.py`) и пользователей `users` (файл в `app/routers/users.py`)... 

Модуль предметов `items` будет иметь переменную роутера `router` (`items.router`). Это тоже самое, что мы и создали в файле `app/routers/items.py`, он является `APIRouter` объектом.

И затем мы делаем тоже самое для модуля пользователей `users`.

Мы могли импортировать их так:

```Python
from app.routers import items, users
```

!!! info
	Первая версия является "родственным импортом":
    ```Python
    from .routers import items, users
    ```
	Вторая версия является "абсолютным импортом"
    ```Python
    from app.routers import items, users
    ```
    Для изучения Python пакетов и модулей, прочитайте <a href="https://docs.python.org/3/tutorial/modules.html" class="external-link" target="_blank">the official Python documentation about Modules</a>.

### Избегайте колизий имен

Мы импортировали подмодуль предметов `items` прямо, вместо импортирования только его переменной роутера `router`. 

Это потому что у нас есть еще одна переменная, названная роутером `router` в подмодуле `users`.

Если бы импортировали модуль за модулем, как в:

```Python
from .routers.items import router
from .routers.users import router
```

Роутер `router` из пользователей `users` переписал бы один из роутеров из модуля предметов `items`, и мы бы не были способны использовать их одновременно.

Так, для того, что бы добавить оба из них для использования в одно и тоже время, мы прямо импортируем подмодули.

```Python hl_lines="4"
{!../../../docs_src/bigger_applications/app/main.py!}
```

### Добавим `APIRouter`ы из пользователей `users` и предметов `items`

Сейчас, давайте добавим роутеры `routers` из подмодулей пользователей `users` и предметов `items`:

```Python hl_lines="10-11"
{!../../../docs_src/bigger_applications/app/main.py!}
```

!!! info
    `users.router` содержит `APIRouter` внутри файла `app/routers/users.py`. 
    `items.router` содержит `APIRouter` внутри файла `app/routers/items.py`.

С `app.include_router()` мы можем добавить каждый `APIRouter` в основной файл `FastAPI` приложения.

Оно будет содержать в себе пути из роутера как его часть.

!!! note "Технические детали"
    Это будет, на саммом деле, создание *операции над url путем* `path operation` внутри для каждой *операцией над путем*, что она была объявлена в `APIRouter`.
    Так, вне основной сцены изменений, это будет, на самом деле, работать, как если бы работало в одном приложении.

!!! check
    Если у Вас беспокойство о производительности при внедрении роутеров.
    Это заберет микросекунды и произойдет при старте.
    Так что, это не повлияет на производительность. ⚡

### Внедрение `APIRouter` с кастомными префиксами `prefix`, тэгами `tags`, ответами `responses`, и зависимостями `dependencies`

Сейчас, давайте представим, Ваша организация дала Вам `app/internal.admin.py` файл.

Он содержит `APIRouter` с некоторыми админ *операциями над url путями*, которыми Ваша организация делится между несколькими проектами.

Для этого приимера это будет очень просто. Но давайте скажем, что потому что эта информация передается другнм проектам в организации, мы не можем модифицировать этот файл и добавить префикс `prefix`, зависимости `dependencies`, тэги `tags`, и т.д прямо до `APIRouter`а:

```Python hl_lines="3"
{!../../../docs_src/bigger_applications/app/internal/admin.py!}
```

Но мы до сих пор хотим установить кастомный префикс `prefix`, когда вносим `APIRouter`, так что все эти *операция над url путями*, начинаются с `/admin`, мы хотим обезопасить их с помощью зависимостей `dependencies`, которые мы уже имеем для этого проекта, и хотим внести теги `tags` и ответы `responses`.

Мы можем определить всё без необходимости модифицирования оригинального `APIRouter` предоставляя те аргументы `app.include_router()`:

```Python hl_lines="14-17"
{!../../../docs_src/bigger_applications/app/main.py!}
```

Таким путем, оригинальный `APIRouter` будет продолжать быть немодифицированным, так мы сможем до сих пор делится тем же файлом `app/internal/admin.py` с другими проектами в организации.

Результатом будет являться то, что в нашем приложении, каждая из *операций над url путем* из `admin` модуля будет иметь

* Префикс `/admin`.
* Тэг `admin`.
* Зависимость `get_token_header`.
* Ответ `418`. 🍵

Но то, что это повлияло на `APIRouter` в нашем приложении, сработало для нас, для другой части кода, что использует его, ничего не поменялось при его использовании.

Так, для примера, другие проекты могли использовать тот же `APIRouter` с другим методом аутентификации.

### Внесение *операции над url путем* `path operation`

Мы так же можем добавить *операции над url путем* `path operation` прямо в приложение `FastAPI`.
 
Здесь мы делаем это... просто что бы показать, что можем 🤷:

```Python hl_lines="21-23"
{!../../../docs_src/bigger_applications/app/main.py!}
```

И это будет работать корректно, вместе со всеми остальными *операциями над url путем* `path operations`, добавленными с `app.include_router()`.

!!! info "Глубокие технические детали"
    **Заметка**: Это глубокая техническая деталь, которую Вы можете **просто пропустить**.
    ---
    `APIRouter`ы не являются "установленными" в коде, они не изолированны от другой части приложения. 
    Это потому что мы хотим внести их *операции над url путями* `path operations` в OpenAPI схему и пользовательские интерфейсы.
    Как мы не можем просто изолировать и "установить" их независимо от всей остальной части код, *операции над url путями* `path operations` являются "клонированными" (пересозданными), не внесенными прямо.

## Проверка автоматической API документации

Так, давайте запустим `uvicorn`, используя модуль `app.main` и переменную `app`:

<div class="termy">

```console
$ uvicorn app.main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

И откроем документацию в <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Вы увидите автоматическую API документацию, содержащую пути из всех подмодулей, используя корректные пути (и префиксы) и корректные теги: 

<img src="/img/tutorial/bigger-applications/image01.png">

## Внесение одного и того же роутера множество раз с разными префиксами `prefix`

Вы можете также использовать `.include_router()` множество раз с *тем же* роутером, используя разные префиксы.

Это может быть полезно, например, для объявления (разоблачения) того же API под разными префиксами, пример - `/api/v1` и `/api/latest`.

Это расширенное использование того, что Вам может и не понадобится, но в любом случае, у Вас есть возможность.

## Внесение `APIRouter`а в другой

Таким же путем Вы можете внести `APIRouter` в `FastAPI` приложение, Вы можете внести `APIRouter` в другой `APIRouter`, используя;

```Python
router.include_router(other_router)
```

Убедитесь вы делаете перед внедрение роутера `router` в `FastAPI` приложения, так что *операции над url путями* `path operations` из другого роутера `other_router` так же внедрены. 

