# Параметры пути

Вы можете задавать "параметры" или "переменные" в пути с тем же синтаксисом, что и в форматных строках Python.

```Python hl_lines="6-7"
{!../../../docs_src/path_params/tutorial001.py!}
```

Значение параметра пути `item_id` будет передано в вашу функцию как аргумент `item_id`.

Таким образом, если вы запустите этот пример и перейдете по адресу <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a>, вы увидите вот такой ответ:

```JSON
{"item_id":"foo"}
```

## Параметры пути с типами

Вы можете добавить описание типа для параметра функции используя стандартные аннотации типов Python.

```Python hl_lines="7"
{!../../../docs_src/path_params/tutorial002.py!}
```

В данном случае, `item_id` объявлен как `int`.

!!! check
    Это позволит вашему редактору выполнять проверку типов, вычислять автодополнение и т.п.

## <abbr title="в том числе: сериализация, парсинг, маршаллинг">Преобразование</abbr> данных

Если вы запустите этот пример и откроете в браузере адрес <a href="http://127.0.0.1:8000/items/3" class="external-link" target="_blank">http://127.0.0.1:8000/items/3</a>, то увидите следующий ответ:

```JSON
{"item_id":3}
```

!!! check
    Обратите внимание, что ваша функция получила не строку `"3"`, а число `3`, типа `int` в Python.

    Т.е. объявление типа дает возможность **FastAPI** автоматически <abbr title="сконвертировать строку, которая поступила с HTTP-запросом, в данные Python">"распарсить"</abbr> запрос.

## Проверка данных

Но если вы зайдете в браузер по адресу <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a>, то увидите симпатичную ошибку:

```JSON
{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}
```

потому что параметр пути `item_id` получил значение `"foo"`, которое не является целым числом, т.е. типом `int`.

Такая же ошибка будет, если вы попытаетесь предоставить значение типа `float` вместо целого числа, например: <a href="http://127.0.0.1:8000/items/4.2" class="external-link" target="_blank">http://127.0.0.1:8000/items/4.2</a>

!!! check
    Таким образом, обычные аннотации типов Python в **FastAPI** используются для проверки (валидации) данных.

    Обратите внимание, что в описании ошибки четко указано, где именно не прошла проверка.

    Это невероятно полезно при разработке и отладке кода, который взаимодействует с вашим API.

## Документирование

А сейчас, если вы откроете страницу в браузере с адресом <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>, то увидите автоматически сгенерированную, интерактивную документацию по API:

<img src="/img/tutorial/path-params/image01.png">

!!! check
    И снова, используя обычные аннотации типов Python, **FastAPI** предоставляет автоматически генерируемую, интерактивную документации (интегрированный Swagger UI).

    Обратите внимание, тип параметра &mdash; integer.

## Преимущества использования стандартов, альтернативная документация

Поскольку генерируемая схема соответствует <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md" class="external-link" target="_blank">OpenAPI</a> стандарту, к ней может быть применено множество совместимых инструментов.

Благодаря этому, сам **FastAPI** предоставляет альтернативное документирование API (с помощью ReDoc), которое доступна по адресу <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>:

<img src="/img/tutorial/path-params/image02.png">

По такому же принципу работают и другие совместимые инструменты. Включая инструменты генерации кода для множества языков.

## Pydantic

Проверка данных выполняется под капотом с помощью <a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic</a>, а значит, доступны все его преимущества. В общем, вы в надежных руках.

Аналогично можно использовать аннотации типов `str`, `float`, `bool` и другие, более сложные типы.

Некоторые из них будут рассмотрены в следующих главах данного руководства.

## Порядок имеет значение

При создании *обработчиков пути* может возникнуть ситуация, в которой будет фиксированный путь.

Например, `/users/me`, предположим, он будет возвращать данные о текущем пользователе.

Также у вас есть путь `/users/{user_id}` для получения данных о конкретном пользователе по его некоторому ID.

Поскольку *обработчики пути* вычисляются по порядку, вам необходимо убедиться, что путь `/users/me` объявлен перед путем `/users/{user_id}`:

```Python hl_lines="6  11"
{!../../../docs_src/path_params/tutorial003.py!}
```

В противном случае пути `/users/{user_id}` будет соответствовать и путь `/users/me`, "считая", что это параметр `user_id` со значением `"me"`.

## Предопределенные значения

Если у вас есть *обработчик пути*, который получает *параметр пути*, но вы хотите, чтобы возможные значения были заранее предопределены, можно воспользоваться стандартным типом Python <abbr title="Enumeration">`Enum`</abbr>.

### Создание класса `Enum`

Импортируйте `Enum` и создайте класс-потомок, наследуемый от `str` и `Enum`.

Наследование от `str` позволяет при документировании API понять, что значения должны быть типа `string`, и правильно их отображать.

Затем добавьте атрибуты класса с фиксированными значениями, которые и станут допустимыми:

```Python hl_lines="1  6-9"
{!../../../docs_src/path_params/tutorial005.py!}
```

!!! info
    <a href="https://docs.python.org/3/library/enum.html" class="external-link" target="_blank">Перечисления доступны в Python</a>, начиная с версии 3.4.

!!! tip
    Если вам интересно, "AlexNet", "ResNet" и "LeNet" - это просто названия <abbr title="Технически, архитектуры моделей глубокого обучения">моделей</abbr> машинного обучения.

### Объявление *параметра пути*

Теперь создайте *параметр пути* с аннотацией типа, используя ранее созданный класс (`ModelName`):

```Python hl_lines="16"
{!../../../docs_src/path_params/tutorial005.py!}
```

### Проверяем документацию

Поскольку возможные значения для *параметра* являются предопределенными, интерактивная документация замечательно их отображает:

<img src="/img/tutorial/path-params/image03.png">

### Работа с *перечислениями* в Python *enumerations*

Значение *параметра пути* является *членом класса перечисления*.

#### Сравнение *членов перечисления*

Вы можете сравнивать параметр с *членами перечисления* созданного вами `ModelName`:

```Python hl_lines="17"
{!../../../docs_src/path_params/tutorial005.py!}
```

#### Получение *значения перечисления*

Можно получить фактическое значение перечисления (типа `str`, в данном случае) с помощью конструкции `model_name.value` или, в общем случае, `your_enum_member.value`:

```Python hl_lines="20"
{!../../../docs_src/path_params/tutorial005.py!}
```

!!! tip
    А еще вы можете получить доступ к значению `"lenet"` с помощью конструкции `ModelName.lenet.value`.

#### Возврат *членов перечисления*

Также можно вернуть *члены перечисления* из вашего *обработчика пути*, можно даже вложенным, например, в словарь (`dict`).

Они будут сконвертированы в соответствующие фактические значения (строки, в нашем случае) перед возвратом клиенту:

```Python hl_lines="18  21  23"
{!../../../docs_src/path_params/tutorial005.py!}
```

В вашем клиенте вы увидите вот такой JSON-ответ:

```JSON
{
  "model_name": "alexnet",
  "message": "Deep Learning FTW!"
}
```

## Параметры пути, содержащие путь

Допустим, у вас есть *обработчик пути* для `/files/{file_path}`.

Но вам надо, чтобы `file_path` тоже содержал некий *путь*, например `home/johndoe/myfile.txt`.

То есть, итоговый URL для этого файла должен быть таким: `/files/home/johndoe/myfile.txt`.

### Поддержка в OpenAPI

В OpenAPI нет никакого способа объявить *параметр пути*, содержащий *путь*, так как это может привести к сценариям, которые трудно протестировать и описать.

Однако, вы все равно можете сделать так в **FastAPI**, с помощью внутренних инструментов Starlette.

Документация будет по прежнему работать, хотя в ней и не будет никакой информации о том, что параметр содержит путь.

### Конвертор пути

Используя опцию Starlette можно объявить *путевой параметр*, содержащий *путь*, в URL вида:

```
/files/{file_path:path}
```

В этом случае именем параметра является `file_path`, а дополнительная часть, `:path`, сообщает, что этот параметр соответствует любому *пути*.

Например:

```Python hl_lines="6"
{!../../../docs_src/path_params/tutorial004.py!}
```

!!! tip
    Возможно, вам необходимо, чтобы параметр содержал `/home/johndoe/myfile.txt`, с ведущим "слэшем" (`/`).

    В этом случае URL должен быть: `/files//home/johndoe/myfile.txt`, с двойным "слэшем" (`//`) между `files` и `home`.

## Резюме

С **FastAPI**, используя короткие, интуитивно понятные и стандартные аннотации типов Python, вы получаете:

* Поддержку в редакторе: проверку ошибок, автодополнение и т.п.
* "<abbr title="конвертирование строк из запроса HTTP в данные (типы) Python">Парсинг</abbr>" данных.
* Проверку (валидацию) данных
* Автоматическую генерацию документации по API

И объявить их нужно только один раз.

Вероятно, это главное явное преимущество **FastAPI** по сравнению с другими фреймворками (помимо чистой производительности).
