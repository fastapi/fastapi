# Особливості

## Особливості FastAPI

**FastAPI** надає наступні можливості:

### Базується на відкритих стандартах

* <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank"><strong>OpenAPI</strong></a> для створення API, включно з декларуванням <abbr title="також відомих як: кінцеві точки або маршрути">шляхів</abbr> <abbr title="також відомих як HTTP методи, наприклад: POST, GET, PUT, DELETE">операцій</abbr>, параметрів, тіла запиту, безпеки та іншим.
* Автоматична документація моделі даних з <a href="http://json-schema.org/" class="external-link" target="_blank"><strong>JSON Schema</strong></a> (так як OpenAPI базується на JSON Schema).
* Спроектовано навколо цих стандартів, після детального вивчення. Замість задумливого шару зверху.
* Це також дозволяє використовувати автоматичні **генератори клієнтського коду** у великій кількості мов програмування.

### Автоматична документація

Інтерактивна API документація та дослідження користувацьких web інтерфейсів. Так як фреймворк базується на OpenAPI, це має декілька стандартних опцій, 2 за замовчуванням.

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank"><strong>Swagger UI</strong></a>, з інтерактивним дослідженням, викликайте та тестуйте Ваше API напряму з браузеру.

![Swagger UI взаємодія](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* Альтернативна API документація з <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank"><strong>ReDoc</strong></a>.

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Просто сучасний Python

Це все базується на стандартах **оголошення типів Python 3.6** (завдяки Pydantic). Немає необхідності вчити новий синтаксис. Лише стандартний та сучасний Python.

Якщо Ви потребуєте 2 хвилини оновлення знань по типам Python (навіть якщо не використовуєте FastAPI), загляніть на короткий туторіал: [типів Python](python-types.md){.internal-link target=_blank}.

Ви пишите стандартний Python з типами:

```Python
from typing import List, Dict
from datetime import date

from pydantic import BaseModel

# Declare a variable as a str
# and get editor support inside the function
def main(user_id: str):
    return user_id


# A Pydantic model
class User(BaseModel):
    id: int
    name: str
    joined: date
```

Потім це може бути використано наступним чином:

```Python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```

!!! Примітка:
    `**second_user_data` означає:

    Передати ключі та значення `second_user_data` словника напряму як ключ-значення аргументи, рівнозначно з: `User(id=4, name="Mary", joined="2018-11-30")`

### Підтримка редактора

Увесь фреймворк спроектований бути легким та інтуїтивним у використанні, усі рішення тестувались на багатьох редакторах навіть до початку розробки, для забезпечення найкращього досвіду розробки.

В останньому опитуванні Python розробників це було чітко визначено <a href="https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features" class="external-link" target="_blank">що найбільш використовувана функція це "автодоповнення"</a>.

Увесь **FastAPI** фреймворк базується для задовільнення цього. Автодоповнення працює усюди.

Ви будете рідко користуватись документацією.

Тут вказано як Ваш редактор може допомагати Вам:

* у <a href="https://code.visualstudio.com/" class="external-link" target="_blank">Visual Studio Code</a>:

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

* у <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a>:

![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)

Ви отримаєте доповнення у коді навіть там, де раніше вважали неможливим. Для прикладу `price` ключ всередині JSON тіла (який може бути вкладеним) та надходить з запиту.

Тепер без написання помилкових назв ключів та повернення до документації по декілька разів для уточнення використання `username` чи `user_name`.

### Короткий

Це має розумні **замовчування** для усього з додатковою концігурацією. Усі параметрі можуть бути налагоджені для роботи з тим, що Вам портрібно та визначення API яке Вам потрібно.

За замовчуванням, це все **"просто працює"**.

### Валідація

* Валідація для більшості (або усіх?) Python **типів даних**, включно з:
    * JSON об'єктами (`dict`).
    * JSON масивами (`list`) визначивши типи полів.
    * Рядковими (`str`) полями, визначивши мінімальну та максимальну довжину.
    * Числами (`int`, `float`) з мінімальним та максимальним значеннями, та іншим.

* Валідація для більш екзотичних типів, наприклад:
    * URL.
    * Email.
    * UUID.
    * ...та інші.

Уся валідація обробляється за допомогою налагодженого та надійного **Pydantic**.

### Безпека та аутентифікація

Безпеку та аутентифікацію включено. Без будь-яких компромісів з базою даних та моделями даних.

Усі схеми безпеки визначено у OpenAPI, включно з:

* HTTP Basic.
* **OAuth2** (також відомий як **JWT tokens**). Дивіться туторіал [OAuth2 з JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.
* API ключами у:
    * Заголовках.
    * Параметрах запиту.
    * Куках та іншому.

Плюс усі особливості безпеки зі Starlette (включно з **куками сесій**).

Усе збудовано як інструменти та компоненти багаторазового використання з простою інтеграцією у Вашу систему, сховища даних, реляційні та NoSQL бази даних та інше.

### Впровадження залежностей

FastAPI включає дуже просту у використанні, але дуже потужну <abbr title='також відому як "компоненти", "ресурси", "сервіси", "провайдери"'><strong>систему впровадження залежностей</strong></abbr>.

* Навіть залежності можуть мати залежності, створюючи ієрархію або **"граф" залежностей**.
* Усе **автоматично обробляється** фреймворком.
* Усі залежності можуть вимагати дані з запиту та **збільшити шлях операції** обмеження та автоматичну документацію.
* **Автоматична валідація** навіть для *шляху операції* параметрів визначених у залежностях.
* Підтрика складних систем аутентифікації користувача, **підключень баз даних** та інше.
* **Ніяких компромісів** з базами даних, фронтендом та іншим. Але легка інтеграція з усіма ними.

### Безмежні "плагіни"

Або з іншого боку, немає потреби у них, імпортуйте та використовуйте код що Вам потрібен.

Будь-яка інтеграція спроектована бути простою у використанні (з залежностями) так, що Ви можете створити "плагін" для Вашого застосунку за допомогою 2 рядків коду використовуючи схожу структуру та синтаксис для Вашого *шляху операції*.

### Протестовано

* 100% <abbr title="Кількість автоматичного протестованого коду">покриття тестами</abbr>.
* 100% <abbr title="Python анотації типів, з редактором та зовнішніми інструментами можуть надати кращу підтримку">анотації типів</abbr> кодової бази.
* Використовується у реальних застосунках.

## Starlette особливості

**FastAPI** повністю сумісний з (і базується на) <a href="https://www.starlette.io/" class="external-link" target="_blank"><strong>Starlette</strong></a>. Тому, будь-який додатковий код Starlette, що Ви маєте буде працювати тут.

`FastAPI` наразі є підкласом `Starlette`. Тому, якщо Ви вже знайомі або використовували Starlette, більша часть функціоналу буде працювати за схожим принципом.

З **FastAPI** Ви отримуєте усі особливості **Starlette** (так як FastAPI це Starlette на стероїдах):

* Серйозно вражаюча швидкодія. Це <a href="https://github.com/encode/starlette#performance" class="external-link" target="_blank">наразі один з найшвидших Python фреймворків, нарівні з **NodeJS** та **Go**</a>.
* підтримка **WebSocket**.
* підтримка **GraphQL**.
* Фонові завдяння у рамках процесу.
* Події увімкнення та вимкнення.
* Тестовий клієнт, побудований на `requests`.
* **CORS**, GZip, Статичні файли, Потокові відповіді.
* Підтримка **Сессій та кук**.
* 100% покриття тестами.
* 100% кодової бази анотації типів.

## Pydantic особливості

**FastAPI** повністю сумісний з (і базується на) <a href="https://pydantic-docs.helpmanual.io" class="external-link" target="_blank"><strong>Pydantic</strong></a>. Тому, будь-який додатковий код Pydantic, що Ви маєте буде працювати тут.

Включно з зовнішніми бібліотеками також базованими на Pydantic, такими як <abbr title="Об'єктно-реляційне відображення">ORM</abbr>s, <abbr title="Об'єктно-документне відображення">ODM</abbr>s для баз даних.

Це такох означає, що у великій кількості випадків Ви можете вказати схожий об'єкт із запиту **напряму до бази даних**, і усе буде провалідоване автоматично.

Те саме стосується інших шляхів навколо, у великій кількості випадків Ви можете вказати схожий об'єкт із бази даних **напряму до клієнта**.

З **FastAPI** Ви отримуєте усі особливості **Pydantic** (так як FastAPI базує усю роботу з даними завдяки Pydantic):

* **без мозгої\*ання**:
    * Без нової схеми визначення мікро-мови для вивчення.
    * Якщо Ви знаєте типи Python - Ви знаєте як використовувати Pydantic.
* Чудово грає з Вашим **<abbr title="Інтегрованим Середовищем Розробки, подібно до редактору коду">IDE</abbr>/<abbr title="Програма для перевірки коду на помилки">linter</abbr>/мозком**:
    * Тому що pydantic структури даних всього-на-всього екземпляри класів що Ви визначаєте; автодоповнення, linting, mypy та Ваша інтуїція мають працювати коректно з Вашою валідацією даних.
* **Швидкий**:
    * у <a href="https://pydantic-docs.helpmanual.io/#benchmarks-tag" class="external-link" target="_blank">бенчмарках</a> Pydantic швидший ніж інші тестовані бібліотеки.
* Валідація **складних структур**:
    * Використовуйте ієрархічні Pydantic моделі, Python `typing`’s `List` та `Dict` та інше.
    * Також валідатори дозволяють складним схемам даних бути зрозумілими та легкими в об'явлені, перевіриними та документованими як JSON Schema.
    * Ви можете мати глубокі **вкладені JSON** об'єкти та все це буде валідоване та анотоване.
* **Розширюваний**:
    * Pydantic дозволяє об'являти костомні типи даних або Ви можете розширювати валідацію з методами декорованої моделі завдяки декоратору валідатора.
* 100% покриття тестами.
