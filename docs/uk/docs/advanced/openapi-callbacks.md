# OpenAPI callbacks { #openapi-callbacks }

Ви можете створити API з *операцією шляху*, яка може запускати запит до *зовнішнього API*, створеного кимось іншим (ймовірно, тим самим розробником, який буде *використовувати* ваше API).

Процес, що відбувається, коли ваш застосунок API викликає *зовнішнє API*, називається «callback». Тому що програмне забезпечення, яке написав зовнішній розробник, надсилає запит до вашого API, а потім ваше API «викликає у відповідь», надсилаючи запит до *зовнішнього API* (яке, ймовірно, створив той самий розробник).

У цьому випадку вам може знадобитися задокументувати, як *має* виглядати це зовнішнє API. Яку *операцію шляху* воно повинно мати, яке тіло має очікувати, яку відповідь має повертати тощо.

## Застосунок із callbacks { #an-app-with-callbacks }

Розгляньмо це на прикладі.

Уявіть, що ви розробляєте застосунок, який дає змогу створювати рахунки.

Ці рахунки матимуть `id`, `title` (необов’язково), `customer` і `total`.

Користувач вашого API (зовнішній розробник) створить рахунок у вашому API за допомогою POST-запиту.

Потім ваше API (уявімо) буде:

* Надсилати рахунок якомусь клієнту зовнішнього розробника.
* Отримувати оплату.
* Надсилати сповіщення назад користувачу API (зовнішньому розробнику).
    * Це буде зроблено шляхом надсилання POST-запиту (від *вашого API*) до певного *зовнішнього API*, наданого цим зовнішнім розробником (це і є «callback»).

## Звичайний застосунок **FastAPI** { #the-normal-fastapi-app }

Спочатку подивімося, як виглядатиме звичайний застосунок API до додавання callback.

Він матиме *операцію шляху*, яка отримуватиме тіло `Invoice`, і query-параметр `callback_url`, що міститиме URL для callback.

Ця частина доволі стандартна, більшість коду вам, ймовірно, уже знайома:

{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[7:11,34:51] *}

/// tip | Порада

Query-параметр `callback_url` використовує тип Pydantic <a href="https://docs.pydantic.dev/latest/api/networks/" class="external-link" target="_blank">Url</a>.

///

Єдине нове тут — це `callbacks=invoices_callback_router.routes` як аргумент для *декоратора операції шляху*. Далі подивимося, що це таке.

## Документування callback { #documenting-the-callback }

Фактичний код callback сильно залежатиме від вашого застосунку API.

І, ймовірно, значно відрізнятиметься від застосунку до застосунку.

Це може бути лише один або два рядки коду, наприклад:

```Python
callback_url = "https://example.com/api/v1/invoices/events/"
httpx.post(callback_url, json={"description": "Invoice paid", "paid": True})
```

Але, можливо, найважливіша частина callback — переконатися, що користувач вашого API (зовнішній розробник) реалізує *зовнішнє API* правильно, відповідно до даних, які *ваше API* надсилатиме в тілі запиту callback тощо.

Тож далі ми додамо код, щоб задокументувати, як має виглядати це *зовнішнє API*, аби приймати callback від *вашого API*.

Ця документація з’явиться в Swagger UI за адресою `/docs` у вашому API і дасть змогу зовнішнім розробникам зрозуміти, як побудувати *зовнішнє API*.

Цей приклад не реалізує сам callback (це може бути просто один рядок коду), лише частину документації.

/// tip | Порада

Фактичний callback — це просто HTTP-запит.

Під час реалізації callback ви можете використати щось на кшталт <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX</a> або <a href="https://requests.readthedocs.io/" class="external-link" target="_blank">Requests</a>.

///

## Напишіть код документації для callback { #write-the-callback-documentation-code }

Цей код не виконуватиметься у вашому застосунку, він потрібен лише для *документування* того, як має виглядати *зовнішнє API*.

Але ви вже знаєте, як легко створювати автоматичну документацію для API з **FastAPI**.

Тож ми використаємо ті самі знання, щоб задокументувати, як має виглядати *зовнішнє API*… створивши *операцію(ї) шляху*, які зовнішнє API повинно реалізувати (ті, які викликатиме ваше API).

/// tip | Порада

Під час написання коду для документування callback може бути корисно уявити, що ви — той *зовнішній розробник*. І що зараз ви реалізуєте *зовнішнє API*, а не *ваше API*.

Тимчасово прийнявши цю точку зору (з позиції *зовнішнього розробника*), вам може бути очевидніше, куди розміщувати параметри, Pydantic-модель для тіла, для відповіді тощо для цього *зовнішнього API*.

///

### Створіть callback `APIRouter` { #create-a-callback-apirouter }

Спочатку створіть новий `APIRouter`, який міститиме один або більше callbacks.

{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[1,23] *}

### Створіть callback *операцію шляху* { #create-the-callback-path-operation }

Щоб створити callback *операцію шляху*, використайте той самий `APIRouter`, який ви створили вище.

Вона має виглядати як звичайна *операція шляху* FastAPI:

* Ймовірно, вона має оголошувати тіло, яке повинна отримувати, наприклад `body: InvoiceEvent`.
* Також вона може оголошувати відповідь, яку повинна повертати, наприклад `response_model=InvoiceEventReceived`.

{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[14:16,19:20,26:30] *}

Є 2 основні відмінності від звичайної *операції шляху*:

* Їй не потрібен жоден фактичний код, бо ваш застосунок ніколи не викликатиме цей код. Його використовують лише для документування *зовнішнього API*. Тому функція може просто містити `pass`.
* *Шлях* може містити <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression" class="external-link" target="_blank">вираз OpenAPI 3</a> (див. більше нижче), де можна використовувати змінні з параметрами та частинами початкового запиту, надісланого до *вашого API*.

### Вираз шляху для callback { #the-callback-path-expression }

Callback-*шлях* може містити <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression" class="external-link" target="_blank">вираз OpenAPI 3</a>, який може включати частини початкового запиту, надісланого до *вашого API*.

У цьому випадку це `str`:

```Python
"{$callback_url}/invoices/{$request.body.id}"
```

Отже, якщо користувач вашого API (зовнішній розробник) надсилає запит до *вашого API* на:

```
https://yourapi.com/invoices/?callback_url=https://www.external.org/events
```

з JSON-тілом:

```JSON
{
    "id": "2expen51ve",
    "customer": "Mr. Richie Rich",
    "total": "9999"
}
```

тоді *ваше API* обробить рахунок і в якийсь момент пізніше надішле callback-запит на `callback_url` (до *зовнішнього API*):

```
https://www.external.org/events/invoices/2expen51ve
```

з JSON-тілом, яке міститиме щось на кшталт:

```JSON
{
    "description": "Payment celebration",
    "paid": true
}
```

і воно очікуватиме відповідь від цього *зовнішнього API* з JSON-тілом на кшталт:

```JSON
{
    "ok": true
}
```

/// tip | Порада

Зверніть увагу: використаний URL для callback містить URL, отриманий як query-параметр у `callback_url` (`https://www.external.org/events`), а також `id` рахунку зсередини JSON-тіла (`2expen51ve`).

///

### Додайте callback router { #add-the-callback-router }

На цьому етапі у вас є потрібні *callback-операції шляху* (ті, які *зовнішній розробник* має реалізувати в *зовнішньому API*) у callback router, який ви створили вище.

Тепер використайте параметр `callbacks` у *декораторі операції шляху вашого API*, щоб передати атрибут `.routes` (це фактично просто `list` маршрутів/*операцій шляху*) з цього callback router:

{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[33] *}

/// tip | Порада

Зверніть увагу, що ви передаєте не сам router (`invoices_callback_router`) у `callback=`, а атрибут `.routes`, тобто `invoices_callback_router.routes`.

///

### Перевірте документацію { #check-the-docs }

Тепер ви можете запустити застосунок і перейти за адресою <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ви побачите вашу документацію, зокрема розділ «Callbacks» для вашої *операції шляху*, який показує, як має виглядати *зовнішнє API*:

<img src="/img/tutorial/openapi-callbacks/image01.png">
