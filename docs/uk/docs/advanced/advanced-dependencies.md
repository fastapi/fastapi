# Розширені залежності { #advanced-dependencies }

## Параметризовані залежності { #parameterized-dependencies }

Усі залежності, які ми бачили, — це фіксована функція або клас.

Але можуть бути випадки, коли ви хочете мати змогу задавати параметри для залежності, не оголошуючи багато різних функцій або класів.

Уявімо, що ми хочемо мати залежність, яка перевіряє, чи містить параметр запиту `q` певний фіксований вміст.

Але ми хочемо мати змогу параметризувати цей фіксований вміст.

## «Callable» екземпляр { #a-callable-instance }

У Python є спосіб зробити екземпляр класу «callable».

Не сам клас (який уже є callable), а екземпляр цього класу.

Для цього ми оголошуємо метод `__call__`:

{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[12] *}

У цьому випадку саме `__call__` **FastAPI** використовуватиме, щоб перевіряти додаткові параметри та підзалежності, і саме його буде викликано, щоб передати значення параметру у вашій *функції операції шляху* пізніше.

## Параметризуйте екземпляр { #parameterize-the-instance }

А тепер ми можемо використати `__init__`, щоб оголосити параметри екземпляра, які ми зможемо використати для «параметризації» залежності:

{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[9] *}

У цьому випадку **FastAPI** ніколи не чіпатиме й не «цікавитиметься» `__init__` — ми використаємо його безпосередньо у своєму коді.

## Створіть екземпляр { #create-an-instance }

Ми можемо створити екземпляр цього класу так:

{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[18] *}

Таким чином ми можемо «параметризувати» нашу залежність, яка тепер містить `"bar"` як атрибут `checker.fixed_content`.

## Використайте екземпляр як залежність { #use-the-instance-as-a-dependency }

Далі ми можемо використати цей `checker` у `Depends(checker)` замість `Depends(FixedContentQueryChecker)`, адже залежністю є екземпляр `checker`, а не сам клас.

І під час розв’язання залежності **FastAPI** викличе цей `checker` так:

```Python
checker(q="somequery")
```

...і передасть те, що він поверне, як значення залежності у нашій *функції операції шляху* в параметр `fixed_content_included`:

{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[22] *}

/// tip | Порада

Усе це може здаватися надуманим. І поки що може бути не дуже зрозуміло, у чому користь.

Ці приклади навмисно прості, але показують, як це все працює.

У розділах про безпеку є допоміжні функції, які реалізовані так само.

Якщо ви все це зрозуміли, то вже знаєте, як «під капотом» працюють ті утиліти для безпеки.

///

## Залежності з `yield`, `HTTPException`, `except` і Background Tasks { #dependencies-with-yield-httpexception-except-and-background-tasks }

/// warning | Попередження

Швидше за все, вам не потрібні ці технічні деталі.

Вони корисні переважно, якщо у вас був застосунок FastAPI старіший за 0.121.0 і ви стикаєтесь із проблемами в залежностях з `yield`.

///

Залежності з `yield` еволюціонували з часом, щоб врахувати різні сценарії використання та виправити деякі проблеми. Нижче наведено підсумок змін.

### Залежності з `yield` і `scope` { #dependencies-with-yield-and-scope }

У версії 0.121.0 FastAPI додав підтримку `Depends(scope="function")` для залежностей з `yield`.

Використовуючи `Depends(scope="function")`, вихідний код після `yield` виконується одразу після завершення *функції операції шляху*, до того як відповідь буде надіслана клієнту.

А при використанні `Depends(scope="request")` (за замовчуванням) вихідний код після `yield` виконується після того, як відповідь надіслано.

Докладніше про це читайте в документації: [Залежності з `yield` — Ранній вихід і `scope`](../tutorial/dependencies/dependencies-with-yield.md#early-exit-and-scope).

### Залежності з `yield` і `StreamingResponse`, технічні деталі { #dependencies-with-yield-and-streamingresponse-technical-details }

До FastAPI 0.118.0, якщо ви використовували залежність з `yield`, вихідний код виконувався після того, як *функція операції шляху* повертала результат, але прямо перед надсиланням відповіді.

Мета була — не утримувати ресурси довше, ніж потрібно, очікуючи, поки відповідь пройде мережею.

Ця зміна також означала, що якщо ви повертали `StreamingResponse`, вихідний код залежності з `yield` уже був би виконаний.

Наприклад, якщо у вас була сесія бази даних у залежності з `yield`, то `StreamingResponse` не зміг би використовувати цю сесію під час стримінгу даних, бо сесію вже було б закрито у вихідному коді після `yield`.

Цю поведінку було повернуто у 0.118.0, щоб вихідний код після `yield` виконувався після надсилання відповіді.

/// info | Інформація

Як ви побачите нижче, це дуже схоже на поведінку до версії 0.106.0, але з кількома покращеннями та виправленнями помилок для крайніх випадків.

///

#### Сценарії з раннім виконанням вихідного коду { #use-cases-with-early-exit-code }

Є деякі сценарії з особливими умовами, у яких могла б бути корисною стара поведінка — виконувати вихідний код залежностей з `yield` перед надсиланням відповіді.

Наприклад, уявімо, що у вас є код, який використовує сесію бази даних у залежності з `yield` лише для перевірки користувача, але сесія більше ніколи не використовується у *функції операції шляху* — лише в залежності — **і** відповідь надсилається довго, як `StreamingResponse`, що повільно передає дані, але з певної причини не використовує базу даних.

У такому випадку сесія бази даних утримуватиметься до завершення надсилання відповіді, але якщо ви її не використовуєте, то це не потрібно.

Ось як це могло б виглядати:

{* ../../docs_src/dependencies/tutorial013_an_py310.py *}

Вихідний код, автоматичне закриття `Session` у:

{* ../../docs_src/dependencies/tutorial013_an_py310.py ln[19:21] *}

...було б виконано після того, як відповідь завершить надсилати повільні дані:

{* ../../docs_src/dependencies/tutorial013_an_py310.py ln[30:38] hl[31:33] *}

Але оскільки `generate_stream()` не використовує сесію бази даних, насправді немає потреби тримати сесію відкритою під час надсилання відповіді.

Якщо у вас є саме такий сценарій із SQLModel (або SQLAlchemy), ви можете явно закрити сесію після того, як вона вам більше не потрібна:

{* ../../docs_src/dependencies/tutorial014_an_py310.py ln[24:28] hl[28] *}

Тоді сесія вивільнить з’єднання з базою даних, і його зможуть використати інші запити.

Якщо у вас є інший сценарій, що потребує раннього виходу із залежності з `yield`, будь ласка, створіть <a href="https://github.com/fastapi/fastapi/discussions/new?category=questions" class="external-link" target="_blank">питання в GitHub Discussions</a> з вашим конкретним сценарієм і поясненням, чому вам було б корисне раннє закриття для залежностей з `yield`.

Якщо знайдуться переконливі сценарії для раннього закриття в залежностях з `yield`, я розгляну можливість додати новий спосіб явно вмикати раннє закриття.

### Залежності з `yield` і `except`, технічні деталі { #dependencies-with-yield-and-except-technical-details }

До FastAPI 0.110.0, якщо ви використовували залежність з `yield`, а потім перехоплювали виняток через `except` у цій залежності і не піднімали виняток знову, виняток автоматично піднімався/передавався будь-яким обробникам винятків або обробнику внутрішньої помилки сервера.

У версії 0.110.0 це було змінено, щоб виправити неконтрольоване споживання пам’яті через переспрямовані винятки без обробника (внутрішні помилки сервера), і щоб узгодити поведінку зі звичайним Python-кодом.

### Background Tasks і залежності з `yield`, технічні деталі { #background-tasks-and-dependencies-with-yield-technical-details }

До FastAPI 0.106.0 піднімати винятки після `yield` було неможливо: вихідний код у залежностях з `yield` виконувався *після* надсилання відповіді, тож [Обробники винятків](../tutorial/handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank} уже відпрацьовували.

Так було спроєктовано переважно для того, щоб дозволити використовувати ті самі об’єкти, «yield»-нуті залежностями, усередині фонових завдань, бо вихідний код виконувався після завершення фонових завдань.

Це було змінено у FastAPI 0.106.0 з наміром не утримувати ресурси під час очікування, поки відповідь пройде мережею.

/// tip | Порада

Крім того, фонове завдання зазвичай є незалежним набором логіки, який слід обробляти окремо, з власними ресурсами (наприклад, власним з’єднанням з базою даних).

Тож у такий спосіб ваш код, імовірно, буде чистішим.

///

Якщо ви раніше покладалися на таку поведінку, тепер вам слід створювати ресурси для фонових завдань усередині самого фонового завдання та використовувати всередині лише дані, які не залежать від ресурсів залежностей з `yield`.

Наприклад, замість використання тієї самої сесії бази даних, ви створите нову сесію бази даних усередині фонового завдання і отримаєте об’єкти з бази даних, використовуючи цю нову сесію. А потім, замість передачі об’єкта з бази даних як параметра у функцію фонового завдання, ви передасте ID цього об’єкта й повторно отримаєте об’єкт усередині функції фонового завдання.
