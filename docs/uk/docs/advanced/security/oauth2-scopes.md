# Області OAuth2 { #oauth2-scopes }

Ви можете використовувати області OAuth2 безпосередньо з **FastAPI** — вони інтегровані так, щоб працювати безшовно.

Це дає змогу мати більш деталізовану систему дозволів, дотримуючись стандарту OAuth2, інтегровану у ваш застосунок OpenAPI (і документацію API).

OAuth2 з областями — це механізм, який використовують багато великих провайдерів автентифікації, як-от Facebook, Google, GitHub, Microsoft, X (Twitter) тощо. Вони застосовують його, щоб надавати користувачам і застосункам конкретні дозволи.

Щоразу, коли ви «входите через» Facebook, Google, GitHub, Microsoft, X (Twitter), цей застосунок використовує OAuth2 з областями.

У цьому розділі ви побачите, як керувати автентифікацією та авторизацією за допомогою того самого OAuth2 з областями у вашому застосунку **FastAPI**.

/// warning | Попередження

Це більш-менш просунутий розділ. Якщо ви лише починаєте, можете його пропустити.

Вам не обов’язково потрібні області OAuth2, і ви можете організувати автентифікацію та авторизацію так, як вам потрібно.

Але OAuth2 з областями можна гарно інтегрувати у ваш API (з OpenAPI) і документацію API.

Водночас ці області, або будь-які інші вимоги безпеки/авторизації, ви все одно застосовуєте так, як потрібно, у вашому коді.

У багатьох випадках OAuth2 з областями може бути надлишковим.

Але якщо ви знаєте, що вам це потрібно, або вам цікаво — читайте далі.

///

## Області OAuth2 та OpenAPI { #oauth2-scopes-and-openapi }

Специфікація OAuth2 визначає «scopes» як список рядків, розділених пробілами.

Вміст кожного з цих рядків може мати будь-який формат, але не повинен містити пробілів.

Ці області представляють «permissions» (дозволи).

В OpenAPI (наприклад, у документації API) ви можете визначати «security schemes».

Коли одна з таких схем безпеки використовує OAuth2, ви також можете оголошувати та використовувати області.

Кожна «scope» — це просто рядок (без пробілів).

Зазвичай їх використовують, щоб оголосити конкретні дозволи безпеки, наприклад:

* `users:read` або `users:write` — поширені приклади.
* `instagram_basic` — використовує Facebook / Instagram.
* `https://www.googleapis.com/auth/drive` — використовує Google.

/// info | Інформація

В OAuth2 «scope» — це просто рядок, що оголошує конкретний необхідний дозвіл.

Не має значення, чи містить він інші символи, як-от `:` або чи є він URL.

Ці деталі залежать від реалізації.

Для OAuth2 це просто рядки.

///

## Загальний огляд { #global-view }

Спочатку швидко подивімося на частини, які змінюються порівняно з прикладами в основному **Підручнику — Посібнику користувача** для [OAuth2 з паролем (і хешуванням), Bearer з JWT токенами](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}. Тепер із використанням областей OAuth2:

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,9,13,47,65,106,108:116,122:126,130:136,141,157] *}

Тепер розгляньмо ці зміни крок за кроком.

## Схема безпеки OAuth2 { #oauth2-security-scheme }

Перша зміна — тепер ми оголошуємо схему безпеки OAuth2 з двома доступними областями: `me` і `items`.

Параметр `scopes` отримує `dict`, де кожна область є ключем, а опис — значенням:

{* ../../docs_src/security/tutorial005_an_py310.py hl[63:66] *}

Оскільки ми тепер оголошуємо ці області, вони з’являться в документації API, коли ви виконаєте вхід/авторизацію.

І ви зможете вибрати, до яких областей хочете надати доступ: `me` і `items`.

Це той самий механізм, який використовується, коли ви надаєте дозволи під час входу через Facebook, Google, GitHub тощо:

<img src="/img/tutorial/security/image11.png">

## JWT токен з областями { #jwt-token-with-scopes }

Тепер змініть *операцію шляху* токена так, щоб вона повертала запитані області.

Ми й далі використовуємо той самий `OAuth2PasswordRequestForm`. Він має властивість `scopes` з `list` із `str`, з кожною областю, яку він отримав у запиті.

І ми повертаємо області як частину JWT токена.

/// danger | Обережно

Для простоти тут ми просто додаємо області, отримані з запиту, безпосередньо до токена.

Але у вашому застосунку, з міркувань безпеки, слід переконатися, що ви додаєте лише ті області, які користувач справді може мати, або ті, які ви попередньо визначили.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[157] *}

## Оголошення областей в *операціях шляху* та залежностях { #declare-scopes-in-path-operations-and-dependencies }

Тепер ми оголошуємо, що *операція шляху* для `/users/me/items/` потребує область `items`.

Для цього ми імпортуємо та використовуємо `Security` з `fastapi`.

Ви можете використовувати `Security`, щоб оголошувати залежності (так само, як `Depends`), але `Security` також отримує параметр `scopes` зі списком областей (рядків).

У цьому випадку ми передаємо функцію залежності `get_current_active_user` до `Security` (так само, як зробили б із `Depends`).

Але також передаємо `list` областей — у цьому випадку лише одну: `items` (може бути й більше).

І функція залежності `get_current_active_user` також може оголошувати підзалежності — не лише через `Depends`, а й через `Security`. Оголошуючи власну функцію підзалежності (`get_current_user`) та додаткові вимоги до областей.

У цьому випадку потрібна область `me` (може вимагатися більше ніж одна область).

/// note | Примітка

Вам не обов’язково додавати різні області в різних місцях.

Ми робимо це тут, щоб показати, як **FastAPI** обробляє області, оголошені на різних рівнях.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,141,172] *}

/// info | Технічні деталі

`Security` насправді є підкласом `Depends` і має лише один додатковий параметр, який ми побачимо пізніше.

Але використовуючи `Security` замість `Depends`, **FastAPI** знатиме, що може оголошувати області безпеки, використовувати їх внутрішньо та документувати API через OpenAPI.

Але коли ви імпортуєте `Query`, `Path`, `Depends`, `Security` та інші з `fastapi`, то це фактично функції, які повертають спеціальні класи.

///

## Використання `SecurityScopes` { #use-securityscopes }

Тепер оновіть залежність `get_current_user`.

Саме її використовують залежності вище.

Тут ми використовуємо ту саму схему OAuth2, яку створили раніше, оголошуючи її як залежність: `oauth2_scheme`.

Оскільки ця функція залежності сама по собі не має вимог до областей, ми можемо використати `Depends` з `oauth2_scheme` — не потрібно використовувати `Security`, коли не треба вказувати області безпеки.

Ми також оголошуємо спеціальний параметр типу `SecurityScopes`, імпортований з `fastapi.security`.

Клас `SecurityScopes` схожий на `Request` (`Request` використовувався для отримання об’єкта запиту напряму).

{* ../../docs_src/security/tutorial005_an_py310.py hl[9,106] *}

## Використання `scopes` { #use-the-scopes }

Параметр `security_scopes` матиме тип `SecurityScopes`.

Він матиме властивість `scopes` зі списком, який містить усі області, потрібні для нього самого та для всіх залежностей, що використовують його як підзалежність. Тобто для всіх «dependants»... це може звучати заплутано — нижче це ще раз пояснюється.

Об’єкт `security_scopes` (класу `SecurityScopes`) також надає атрибут `scope_str` з одним рядком, що містить ці області, розділені пробілами (ми будемо це використовувати).

Ми створюємо `HTTPException`, який можемо повторно використовувати (`raise`) у кількох місцях.

У цьому винятку ми включаємо потрібні області (якщо є) у вигляді рядка, розділеного пробілами (використовуючи `scope_str`). Цей рядок з областями ми поміщаємо в заголовок `WWW-Authenticate` (це частина специфікації).

{* ../../docs_src/security/tutorial005_an_py310.py hl[106,108:116] *}

## Перевірка `username` і структури даних { #verify-the-username-and-data-shape }

Ми перевіряємо, що отримали `username`, і витягаємо області.

Далі валідуюємо ці дані за допомогою Pydantic-моделі (перехоплюючи виняток `ValidationError`), і якщо під час читання JWT токена або перевірки даних через Pydantic виникає помилка — піднімаємо `HTTPException`, який створили раніше.

Для цього ми оновлюємо Pydantic-модель `TokenData`, додаючи нову властивість `scopes`.

Валідуючи дані через Pydantic, ми можемо переконатися, що маємо, наприклад, рівно `list` із `str` для областей та `str` для `username`.

А не, наприклад, `dict` чи щось інше, що могло б зламати застосунок пізніше і створити ризик безпеки.

Ми також перевіряємо, що існує користувач із таким `username`, і якщо ні — піднімаємо той самий виняток, який створили раніше.

{* ../../docs_src/security/tutorial005_an_py310.py hl[47,117:129] *}

## Перевірка `scopes` { #verify-the-scopes }

Тепер ми перевіряємо, що всі області, потрібні для цієї залежності та всіх «dependants» (включно з *операціями шляху*), присутні в областях, наданих у отриманому токені. Інакше піднімаємо `HTTPException`.

Для цього використовуємо `security_scopes.scopes`, що містить `list` усіх цих областей як `str`.

{* ../../docs_src/security/tutorial005_an_py310.py hl[130:136] *}

## Дерево залежностей та області { #dependency-tree-and-scopes }

Розгляньмо ще раз це дерево залежностей та області.

Оскільки залежність `get_current_active_user` має підзалежність `get_current_user`, область `"me"`, оголошена в `get_current_active_user`, буде включена до списку потрібних областей у `security_scopes.scopes`, переданому в `get_current_user`.

Сама *операція шляху* також оголошує область `"items"`, тож вона теж буде в списку `security_scopes.scopes`, переданому в `get_current_user`.

Ось як виглядає ієрархія залежностей та областей:

* *Операція шляху* `read_own_items` має:
    * Потрібні області `["items"]` із залежністю:
    * `get_current_active_user`:
        * Функція залежності `get_current_active_user` має:
            * Потрібні області `["me"]` із залежністю:
            * `get_current_user`:
                * Функція залежності `get_current_user` має:
                    * Немає областей, потрібних для неї самої.
                    * Залежність, що використовує `oauth2_scheme`.
                    * Параметр `security_scopes` типу `SecurityScopes`:
                        * Цей параметр `security_scopes` має властивість `scopes` із `list`, який містить усі оголошені вище області, отже:
                            * `security_scopes.scopes` міститиме `["me", "items"]` для *операції шляху* `read_own_items`.
                            * `security_scopes.scopes` міститиме `["me"]` для *операції шляху* `read_users_me`, бо вона оголошена в залежності `get_current_active_user`.
                            * `security_scopes.scopes` міститиме `[]` (нічого) для *операції шляху* `read_system_status`, бо вона не оголосила жодного `Security` зі `scopes`, і її залежність `get_current_user` також не оголошує жодних `scopes`.

/// tip | Порада

Важлива й «магічна» річ тут у тому, що `get_current_user` матиме різний список `scopes` для перевірки для кожної *операції шляху*.

Усе залежить від `scopes`, оголошених у кожній *операції шляху* та в кожній залежності в дереві залежностей для цієї конкретної *операції шляху*.

///

## Докладніше про `SecurityScopes` { #more-details-about-securityscopes }

Ви можете використовувати `SecurityScopes` у будь-якій точці й у кількох місцях — він не обов’язково має бути в «кореневій» залежності.

Він завжди міститиме області безпеки, оголошені в поточних залежностях `Security`, та у всіх «dependants» для **саме цієї** *операції шляху* і **саме цього** дерева залежностей.

Оскільки `SecurityScopes` міститиме всі області, оголошені «dependants», ви можете використати його, щоб перевіряти наявність потрібних областей у токені в центральній функції залежності, а потім оголошувати різні вимоги до областей у різних *операціях шляху*.

Вони перевірятимуться незалежно для кожної *операції шляху*.

## Перевірте { #check-it }

Якщо ви відкриєте документацію API, ви зможете автентифікуватися та вказати, які області ви хочете авторизувати.

<img src="/img/tutorial/security/image11.png">

Якщо ви не виберете жодної області, ви будете «автентифіковані», але коли спробуєте отримати доступ до `/users/me/` або `/users/me/items/`, отримаєте помилку про недостатні дозволи. Водночас ви все ще зможете отримати доступ до `/status/`.

А якщо ви виберете область `me`, але не область `items`, ви зможете отримати доступ до `/users/me/`, але не до `/users/me/items/`.

Саме так поводитиметься сторонній застосунок, який спробував би отримати доступ до однієї з цих *операцій шляху* з токеном, наданим користувачем, залежно від того, скільки дозволів користувач надав цьому застосунку.

## Про інтеграції зі сторонніми застосунками { #about-third-party-integrations }

У цьому прикладі ми використовуємо OAuth2 «password» flow.

Це доречно, коли ми входимо у власний застосунок — імовірно, через власний frontend.

Тому що ми можемо довіряти йому отримання `username` та `password`, адже ми його контролюємо.

Але якщо ви створюєте OAuth2-застосунок, до якого підключатимуться інші (тобто якщо ви створюєте провайдера автентифікації на кшталт Facebook, Google, GitHub тощо), вам слід використати один з інших flow.

Найпоширеніший — implicit flow.

Найбезпечніший — code flow, але його складніше реалізувати, бо він вимагає більше кроків. Через цю складність багато провайдерів у підсумку рекомендують implicit flow.

/// note | Примітка

Часто кожен провайдер автентифікації називає свої flow по-різному, роблячи це частиною бренду.

Але зрештою вони реалізують той самий стандарт OAuth2.

///

**FastAPI** містить утиліти для всіх цих OAuth2 flow автентифікації в `fastapi.security.oauth2`.

## `Security` у параметрі декоратора `dependencies` { #security-in-decorator-dependencies }

Так само, як ви можете визначити `list` із `Depends` у параметрі декоратора `dependencies` (як пояснено в [Залежності в декораторах операцій шляху](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}), ви також можете використати там `Security` зі `scopes`.
