# HTTP Basic Auth { #http-basic-auth }

Для найпростіших випадків ви можете використати HTTP Basic Auth.

У HTTP Basic Auth застосунок очікує заголовок, що містить ім’я користувача та пароль.

Якщо він його не отримує, то повертає помилку HTTP 401 «Unauthorized».

Також повертає заголовок `WWW-Authenticate` зі значенням `Basic` і необов’язковим параметром `realm`.

Це повідомляє браузеру показати вбудоване вікно запиту імені користувача та пароля.

Далі, коли ви вводите це ім’я користувача та пароль, браузер автоматично надсилає їх у заголовку.

## Простий HTTP Basic Auth { #simple-http-basic-auth }

* Імпортуйте `HTTPBasic` і `HTTPBasicCredentials`.
* Створіть «`security` scheme», використовуючи `HTTPBasic`.
* Використайте цей `security` із залежністю у вашій *операції шляху*.
* Він повертає об’єкт типу `HTTPBasicCredentials`:
    * Він містить надіслані `username` і `password`.

{* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}

Коли ви намагаєтеся відкрити URL уперше (або натискаєте кнопку «Execute» в документації), браузер попросить вас ввести ім’я користувача та пароль:

<img src="/img/tutorial/security/image12.png">

## Перевірка імені користувача { #check-the-username }

Ось більш повний приклад.

Використайте залежність, щоб перевірити, чи правильні ім’я користувача та пароль.

Для цього використайте стандартний модуль Python <a href="https://docs.python.org/3/library/secrets.html" class="external-link" target="_blank">`secrets`</a>, щоб перевірити ім’я користувача та пароль.

`secrets.compare_digest()` має отримувати `bytes` або `str`, що містить лише ASCII-символи (англійські), тобто він не працюватиме з такими символами, як `á`, наприклад у `Sebastián`.

Щоб це обійти, спочатку перетворимо `username` і `password` на `bytes`, закодувавши їх у UTF-8.

Після цього можна використати `secrets.compare_digest()`, щоб переконатися, що `credentials.username` дорівнює `"stanleyjobson"`, а `credentials.password` — `"swordfish"`.

{* ../../docs_src/security/tutorial007_an_py39.py hl[1,12:24] *}

Це було б схоже на:

```Python
if not (credentials.username == "stanleyjobson") or not (credentials.password == "swordfish"):
    # Return some error
    ...
```

Але завдяки використанню `secrets.compare_digest()` це буде захищено від типу атак, що називаються «timing attacks».

### Timing Attacks { #timing-attacks }

Але що таке «timing attack»?

Уявімо, що зловмисники намагаються вгадати ім’я користувача та пароль.

І вони надсилають запит з іменем користувача `johndoe` і паролем `love123`.

Тоді Python-код у вашому застосунку буде еквівалентний приблизно такому:

```Python
if "johndoe" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Але в момент, коли Python порівнює першу літеру `j` у `johndoe` з першою літерою `s` у `stanleyjobson`, він одразу поверне `False`, бо вже знає, що ці два рядки не однакові, і вважає, що «немає потреби витрачати додаткові обчислення на порівняння решти літер». І ваш застосунок скаже: «Incorrect username or password».

Потім зловмисники пробують ім’я користувача `stanleyjobsox` і пароль `love123`.

І код вашого застосунку робить щось на кшталт:

```Python
if "stanleyjobsox" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Python доведеться порівняти весь фрагмент `stanleyjobso` в `stanleyjobsox` і `stanleyjobson`, перш ніж зрозуміти, що рядки відрізняються. Тож відповідь «Incorrect username or password» займе на кілька мікросекунд більше.

#### Час відповіді допомагає зловмисникам { #the-time-to-answer-helps-the-attackers }

У цей момент, помітивши, що сервер витратив на кілька мікросекунд більше на надсилання відповіді «Incorrect username or password», зловмисники зрозуміють, що вони _в чомусь_ праві — деякі початкові літери збіглися.

І тоді вони можуть повторити спробу, знаючи, що правильне значення, ймовірно, ближче до `stanleyjobsox`, ніж до `johndoe`.

#### «Професійна» атака { #a-professional-attack }

Звісно, зловмисники не робитимуть це вручну — вони напишуть програму, можливо, з тисячами або мільйонами перевірок за секунду. І щоразу отримуватимуть лише одну додаткову правильну літеру.

Але так, за кілька хвилин або годин, зловмисники вгадають правильні ім’я користувача та пароль за «допомогою» нашого застосунку, використовуючи лише час, потрібний для відповіді.

#### Виправлення за допомогою `secrets.compare_digest()` { #fix-it-with-secrets-compare-digest }

Але в нашому коді ми фактично використовуємо `secrets.compare_digest()`.

Коротко кажучи, він витрачатиме однаковий час на порівняння `stanleyjobsox` із `stanleyjobson`, як і на порівняння `johndoe` із `stanleyjobson`. І так само для пароля.

Таким чином, використовуючи `secrets.compare_digest()` у коді вашого застосунку, ви будете захищені від усього цього класу атак безпеки.

### Повернення помилки { #return-the-error }

Після виявлення, що облікові дані некоректні, поверніть `HTTPException` зі статус-кодом 401 (таким самим, як і коли облікові дані не надано) і додайте заголовок `WWW-Authenticate`, щоб браузер знову показав запит на вхід:

{* ../../docs_src/security/tutorial007_an_py39.py hl[26:30] *}
