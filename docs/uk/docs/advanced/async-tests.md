# Асинхронні тести { #async-tests }

Ви вже бачили, як тестувати ваші застосунки **FastAPI** за допомогою наданого `TestClient`. До цього моменту ви бачили лише те, як писати синхронні тести, без використання `async`-функцій.

Можливість використовувати асинхронні функції у ваших тестах може бути корисною, наприклад, коли ви асинхронно виконуєте запити до бази даних. Уявіть, що ви хочете протестувати надсилання запитів до вашого застосунку FastAPI, а потім перевірити, що ваш backend успішно записав правильні дані в базу даних, використовуючи async-бібліотеку для роботи з БД.

Подивімося, як це реалізувати.

## pytest.mark.anyio { #pytest-mark-anyio }

Якщо ми хочемо викликати асинхронні функції в наших тестах, наші тестові функції теж мають бути асинхронними. AnyIO надає зручний плагін для цього, який дозволяє нам вказати, що деякі тестові функції слід викликати асинхронно.

## HTTPX { #httpx }

Навіть якщо ваш застосунок **FastAPI** використовує звичайні `def`-функції замість `async def`, під капотом це все одно `async`-застосунок.

`TestClient` виконує певну «магію» всередині, щоб викликати асинхронний застосунок FastAPI у ваших звичайних `def` тестових функціях, використовуючи стандартний pytest. Але ця магія більше не працює, коли ми використовуємо його всередині асинхронних функцій. Запускаючи наші тести асинхронно, ми більше не можемо використовувати `TestClient` усередині тестових функцій.

`TestClient` базується на <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX</a>, і, на щастя, ми можемо використовувати його напряму для тестування API.

## Приклад { #example }

Для простого прикладу розгляньмо структуру файлів, схожу на описану в [Більші застосунки](../tutorial/bigger-applications.md){.internal-link target=_blank} та [Тестування](../tutorial/testing.md){.internal-link target=_blank}:

```
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
```

Файл `main.py` матиме:

{* ../../docs_src/async_tests/app_a_py39/main.py *}

Файл `test_main.py` матиме тести для `main.py`, і тепер він може виглядати так:

{* ../../docs_src/async_tests/app_a_py39/test_main.py *}

## Запуск { #run-it }

Ви можете запускати тести як зазвичай, через:

<div class="termy">

```console
$ pytest

---> 100%
```

</div>

## Детальніше { #in-detail }

Маркер `@pytest.mark.anyio` повідомляє pytest, що цю тестову функцію потрібно викликати асинхронно:

{* ../../docs_src/async_tests/app_a_py39/test_main.py hl[7] *}

/// tip | Порада

Зверніть увагу, що тепер тестова функція — це `async def`, а не просто `def`, як раніше при використанні `TestClient`.

///

Потім ми можемо створити `AsyncClient` із застосунком і надсилати до нього async-запити, використовуючи `await`.

{* ../../docs_src/async_tests/app_a_py39/test_main.py hl[9:12] *}

Це еквівалентно:

```Python
response = client.get('/')
```

...що ми використовували для виконання запитів через `TestClient`.

/// tip | Порада

Зверніть увагу, що з новим `AsyncClient` ми використовуємо async/await — запит є асинхронним.

///

/// warning | Попередження

Якщо ваш застосунок покладається на події життєвого циклу (lifespan events), `AsyncClient` не запускатиме ці події. Щоб гарантувати їх запуск, використовуйте `LifespanManager` з <a href="https://github.com/florimondmanca/asgi-lifespan#usage" class="external-link" target="_blank">florimondmanca/asgi-lifespan</a>.

///

## Інші виклики асинхронних функцій { #other-asynchronous-function-calls }

Оскільки тестова функція тепер асинхронна, ви також можете викликати (і `await`-ити) інші `async`-функції, окрім надсилання запитів до вашого застосунку FastAPI в тестах — так само, як ви викликали б їх будь-де в іншому місці вашого коду.

/// tip | Порада

Якщо під час інтеграції викликів асинхронних функцій у тести ви стикаєтеся з `RuntimeError: Task attached to a different loop` (наприклад, при використанні <a href="https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop" class="external-link" target="_blank">MongoDB's MotorClient</a>), пам’ятайте: об’єкти, яким потрібен event loop, слід створювати лише всередині async-функцій, наприклад, у callback `@app.on_event("startup")`.

///
