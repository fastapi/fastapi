# Генерація SDK { #generating-sdks }

Оскільки **FastAPI** базується на специфікації **OpenAPI**, його API можна описати у стандартному форматі, який розуміє багато інструментів.

Це спрощує генерацію актуальної **документації**, клієнтських бібліотек (<abbr title="Software Development Kits - Набори засобів розробки програмного забезпечення">**SDKs**</abbr>) кількома мовами, а також **тестування** чи **workflow для автоматизації**, які залишаються синхронізованими з вашим кодом.

У цьому посібнику ви дізнаєтеся, як згенерувати **TypeScript SDK** для вашого FastAPI бекенду.

## Open Source генератори SDK { #open-source-sdk-generators }

Універсальний варіант — <a href="https://openapi-generator.tech/" class="external-link" target="_blank">OpenAPI Generator</a>, який підтримує **багато мов програмування** і може генерувати SDK з вашої OpenAPI специфікації.

Для **TypeScript-клієнтів** <a href="https://heyapi.dev/" class="external-link" target="_blank">Hey API</a> — спеціалізоване рішення, що забезпечує оптимізований досвід для екосистеми TypeScript.

Більше генераторів SDK можна знайти на <a href="https://openapi.tools/#sdk" class="external-link" target="_blank">OpenAPI.Tools</a>.

/// tip | Порада

FastAPI автоматично генерує специфікації **OpenAPI 3.1**, тож будь-який інструмент, який ви використовуєте, має підтримувати цю версію.

///

## Генератори SDK від спонсорів FastAPI { #sdk-generators-from-fastapi-sponsors }

У цьому розділі зібрано рішення, що **підтримуються венчурним капіталом** і **компаніями**, від компаній-спонсорів FastAPI. Ці продукти надають **додаткові можливості** та **інтеграції** поверх якісно згенерованих SDK.

Спонсоруючи ✨ [**FastAPI**](../help-fastapi.md#sponsor-the-author){.internal-link target=_blank} ✨, ці компанії допомагають зберігати фреймворк та його **екосистему** здоровими й **стійкими**.

Їхнє спонсорство також демонструє сильну відданість **спільноті** FastAPI (вам), показуючи, що їм важливо не лише пропонувати **якісний сервіс**, а й підтримувати **надійний і процвітаючий фреймворк** FastAPI.

Наприклад, ви можете спробувати:

* <a href="https://speakeasy.com/editor?utm_source=fastapi+repo&utm_medium=github+sponsorship" class="external-link" target="_blank">Speakeasy</a>
* <a href="https://www.stainless.com/?utm_source=fastapi&utm_medium=referral" class="external-link" target="_blank">Stainless</a>
* <a href="https://developers.liblab.com/tutorials/sdk-for-fastapi?utm_source=fastapi" class="external-link" target="_blank">liblab</a>

Деякі з цих рішень також можуть бути open source або мати безплатні тарифи, тож ви можете спробувати їх без фінансових зобов’язань. Також доступні інші комерційні генератори SDK, їх можна знайти онлайн.

## Створення TypeScript SDK { #create-a-typescript-sdk }

Почнімо з простого застосунку FastAPI:

{* ../../docs_src/generate_clients/tutorial001_py39.py hl[7:9,12:13,16:17,21] *}

Зверніть увагу, що *операції шляху* визначають моделі, які вони використовують для тіла запиту та тіла відповіді, використовуючи моделі `Item` і `ResponseMessage`.

### Документація API { #api-docs }

Якщо перейти на `/docs`, ви побачите **схеми** для даних, які надсилаються в запитах і отримуються у відповідях:

<img src="/img/tutorial/generate-clients/image01.png">

Ви бачите ці схеми, тому що їх було оголошено моделями в застосунку.

Ця інформація доступна в **OpenAPI схемі** застосунку, а далі відображається в документації API.

Саме ця інформація з моделей, включена в OpenAPI, і може бути використана для **генерації клієнтського коду**.

### Hey API { #hey-api }

Коли у нас є застосунок FastAPI з моделями, ми можемо використати Hey API для генерації TypeScript-клієнта. Найшвидший спосіб — через npx.

```sh
npx @hey-api/openapi-ts -i http://localhost:8000/openapi.json -o src/client
```

Це згенерує TypeScript SDK у `./src/client`.

Ви можете дізнатися, як <a href="https://heyapi.dev/openapi-ts/get-started" class="external-link" target="_blank">встановити `@hey-api/openapi-ts`</a>, а також прочитати про <a href="https://heyapi.dev/openapi-ts/output" class="external-link" target="_blank">згенерований результат</a> на їхньому сайті.

### Використання SDK { #using-the-sdk }

Тепер ви можете імпортувати та використовувати клієнтський код. Це може виглядати так — зверніть увагу, що ви отримуєте автодоповнення для методів:

<img src="/img/tutorial/generate-clients/image02.png">

Ви також отримаєте автодоповнення для payload, який потрібно надіслати:

<img src="/img/tutorial/generate-clients/image03.png">

/// tip | Порада

Зверніть увагу на автодоповнення для `name` і `price` — це було визначено в застосунку FastAPI, у моделі `Item`.

///

Також ви матимете inline-помилки для даних, які надсилаєте:

<img src="/img/tutorial/generate-clients/image04.png">

Об’єкт відповіді також матиме автодоповнення:

<img src="/img/tutorial/generate-clients/image05.png">

## Застосунок FastAPI з тегами { #fastapi-app-with-tags }

У багатьох випадках ваш застосунок FastAPI буде більшим, і ви, ймовірно, використовуватимете теги, щоб розділяти різні групи *операцій шляху*.

Наприклад, у вас може бути секція для **items** і інша секція для **users**, і їх можна розділити тегами:

{* ../../docs_src/generate_clients/tutorial002_py39.py hl[21,26,34] *}

### Генерація TypeScript-клієнта з тегами { #generate-a-typescript-client-with-tags }

Якщо ви генеруєте клієнт для застосунку FastAPI з використанням тегів, зазвичай клієнтський код також буде розділено відповідно до тегів.

Так ви зможете мати впорядковане й коректно згруповане клієнтське API:

<img src="/img/tutorial/generate-clients/image06.png">

У цьому випадку у вас є:

* `ItemsService`
* `UsersService`

### Назви методів клієнта { #client-method-names }

Зараз згенеровані назви методів на кшталт `createItemItemsPost` виглядають не дуже охайно:

```TypeScript
ItemsService.createItemItemsPost({name: "Plumbus", price: 5})
```

...це тому, що генератор клієнта використовує внутрішній **operation ID** OpenAPI для кожної *операції шляху*.

OpenAPI вимагає, щоб кожен operation ID був унікальним серед усіх *операцій шляху*, тож FastAPI використовує **ім’я функції**, **шлях** і **HTTP метод/операцію**, щоб згенерувати цей operation ID — так він може гарантувати унікальність.

Але далі я покажу, як це покращити.

## Власні Operation ID і кращі назви методів { #custom-operation-ids-and-better-method-names }

Ви можете **змінити** спосіб **генерації** цих operation ID, щоб зробити їх простішими та отримати **простішi назви методів** у клієнтах.

У такому разі вам потрібно забезпечити, щоб кожен operation ID був **унікальним** іншим способом.

Наприклад, ви можете гарантувати, що кожна *операція шляху* має тег, а потім генерувати operation ID на основі **тега** та **назви** *операції шляху* (імені функції).

### Власна функція генерації унікального ID { #custom-generate-unique-id-function }

FastAPI використовує **унікальний ID** для кожної *операції шляху*, який застосовується для **operation ID**, а також для назв потрібних кастомних моделей для запитів або відповідей.

Ви можете налаштувати цю функцію. Вона приймає `APIRoute` і повертає рядок.

Наприклад, тут вона використовує перший тег (у вас, імовірно, буде лише один тег) і назву *операції шляху* (ім’я функції).

Потім ви можете передати цю функцію в **FastAPI** як параметр `generate_unique_id_function`:

{* ../../docs_src/generate_clients/tutorial003_py39.py hl[6:7,10] *}

### Генерація TypeScript-клієнта з власними Operation ID { #generate-a-typescript-client-with-custom-operation-ids }

Тепер, якщо згенерувати клієнт знову, ви побачите, що він має покращені назви методів:

<img src="/img/tutorial/generate-clients/image07.png">

Як бачите, назви методів тепер містять тег, а далі — ім’я функції; вони більше не включають інформацію з URL-шляху та HTTP-операції.

### Попередня обробка OpenAPI специфікації для генератора клієнта { #preprocess-the-openapi-specification-for-the-client-generator }

Згенерований код усе ще містить деяку **дубльовану інформацію**.

Ми вже знаємо, що цей метод пов’язаний з **items**, бо це слово є в `ItemsService` (взято з тега), але в назві методу все ще є префікс із назвою тега.

Ймовірно, для OpenAPI загалом ми все одно захочемо це зберегти, адже це забезпечить **унікальність** operation ID.

Але для згенерованого клієнта ми можемо **змінити** operation ID в OpenAPI прямо перед генерацією клієнтів — лише щоб зробити назви методів гарнішими та **чистішими**.

Можна завантажити OpenAPI JSON у файл `openapi.json`, а потім **прибрати цей префікс тега** скриптом на кшталт такого:

{* ../../docs_src/generate_clients/tutorial004_py39.py *}

//// tab | Node.js

```Javascript
{!> ../../docs_src/generate_clients/tutorial004.js!}
```

////

Після цього operation ID буде перейменовано з варіантів на кшталт `items-get_items` просто на `get_items`, і генератор клієнта зможе створювати простіші назви методів.

### Генерація TypeScript-клієнта з попередньо обробленим OpenAPI { #generate-a-typescript-client-with-the-preprocessed-openapi }

Оскільки кінцевий результат тепер у файлі `openapi.json`, вам потрібно оновити шлях до вхідних даних:

```sh
npx @hey-api/openapi-ts -i ./openapi.json -o src/client
```

Після генерації нового клієнта ви матимете **чисті назви методів** з усім **автодоповненням**, **inline-помилками** тощо:

<img src="/img/tutorial/generate-clients/image08.png">

## Переваги { #benefits }

Використовуючи автоматично згенеровані клієнти, ви отримуєте **автодоповнення** для:

* Методів.
* Payload запиту в тілі, query-параметрів тощо.
* Payload відповіді.

Також ви матимете **inline-помилки** для всього.

І щоразу, коли ви оновлюєте код бекенду та **перегенеровуєте** фронтенд, нові *операції шляху* будуть доступні як методи, старі — видалені, а будь-які інші зміни відобразяться в згенерованому коді.

Це також означає, що якщо щось змінилося, це автоматично **відобразиться** в клієнтському коді. А якщо ви **збираєте** (build) клієнт, збірка завершиться помилкою, якщо є будь-яка **невідповідність** у використовуваних даних.

Отже, ви зможете **виявляти багато помилок** дуже рано в циклі розробки, замість того щоб чекати, поки помилки проявляться у ваших кінцевих користувачів у production, а потім намагатися відлагодити, де саме проблема.
