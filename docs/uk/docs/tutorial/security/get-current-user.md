# Отримання поточного користувача { #get-current-user }

У попередньому розділі система безпеки (яка базується на системі ін’єкції залежностей) передавала *функції операції шляху* `token` як `str`:

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Але це все ще не надто корисно.

Зробімо так, щоб вона повертала нам поточного користувача.

## Створення моделі користувача { #create-a-user-model }

Спочатку створімо модель користувача Pydantic.

Так само, як ми використовуємо Pydantic для оголошення тіл, ми можемо використовувати його будь-де:

{* ../../docs_src/security/tutorial002_an_py310.py hl[5,12:6] *}

## Створення залежності `get_current_user` { #create-a-get-current-user-dependency }

Створімо залежність `get_current_user`.

Пам’ятаєте, що залежності можуть мати підзалежності?

`get_current_user` матиме залежність із тим самим `oauth2_scheme`, який ми створили раніше.

Так само, як ми робили раніше безпосередньо в *операції шляху*, наша нова залежність `get_current_user` отримуватиме `token` як `str` із підзалежності `oauth2_scheme`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[25] *}

## Отримання користувача { #get-the-user }

`get_current_user` використає (фейкову) допоміжну функцію, яку ми створили; вона приймає токен як `str` і повертає нашу модель Pydantic `User`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[19:22,26:27] *}

## Ін’єкція поточного користувача { #inject-the-current-user }

Тож тепер ми можемо використати той самий `Depends` із нашим `get_current_user` в *операції шляху*:

{* ../../docs_src/security/tutorial002_an_py310.py hl[31] *}

Зверніть увагу, що ми оголошуємо тип `current_user` як модель Pydantic `User`.

Це допоможе нам усередині функції завдяки автодоповненню та перевіркам типів.

/// tip | Порада

Можливо, ви пам’ятаєте, що тіла запитів також оголошуються за допомогою моделей Pydantic.

Тут **FastAPI** не заплутається, бо ви використовуєте `Depends`.

///

/// check

Те, як спроєктовано цю систему залежностей, дозволяє мати різні залежності (різні «dependables»), які всі повертають модель `User`.

Ми не обмежені лише однією залежністю, яка може повертати цей тип даних.

///

## Інші моделі { #other-models }

Тепер ви можете отримувати поточного користувача напряму в *функціях операцій шляху* і працювати з механізмами безпеки на рівні **Dependency Injection**, використовуючи `Depends`.

І ви можете використовувати будь-яку модель або дані для вимог безпеки (у цьому випадку — модель Pydantic `User`).

Але ви не обмежені використанням якоїсь конкретної моделі даних, класу чи типу.

Хочете мати `id` та `email` і не мати жодного `username` у вашій моделі? Звісно. Ви можете використати ці самі інструменти.

Хочете мати лише `str`? Або лише `dict`? Або напряму інстанс моделі класу бази даних? Усе працює так само.

Насправді у вас немає користувачів, які входять у ваш застосунок, а є роботи, боти чи інші системи, що мають лише токен доступу? Знову ж, усе працює так само.

Просто використовуйте будь-який тип моделі, будь-який клас, будь-яку базу даних, які потрібні для вашого застосунку. **FastAPI** покриває це системою ін’єкції залежностей.

## Розмір коду { #code-size }

Цей приклад може здатися багатослівним. Майте на увазі, що ми змішуємо безпеку, моделі даних, допоміжні функції та *операції шляху* в одному файлі.

Але ось ключовий момент.

Уся логіка безпеки та ін’єкції залежностей пишеться один раз.

І ви можете зробити її настільки складною, наскільки захочете. І при цьому вона все одно буде написана лише один раз, в одному місці. З усією гнучкістю.

Але ви можете мати тисячі endpoint’ів (*операцій шляху*), що використовують ту саму систему безпеки.

І всі вони (або будь-яка їх частина, яку ви захочете) можуть скористатися повторним використанням цих залежностей або будь-яких інших залежностей, які ви створите.

І всі ці тисячі *операцій шляху* можуть бути такими короткими, як 3 рядки:

{* ../../docs_src/security/tutorial002_an_py310.py hl[30:32] *}

## Підсумок { #recap }

Тепер ви можете отримувати поточного користувача безпосередньо у вашій *функції операції шляху*.

Ми вже на пів шляху.

Нам лише потрібно додати *операцію шляху*, щоб користувач/клієнт міг насправді надіслати `username` і `password`.

Це буде далі.
