# Безпека — перші кроки { #security-first-steps }

Уявімо, що у вас є **backend** API в якомусь домені.

І у вас є **frontend** в іншому домені або в іншому шляху того самого домену (або в мобільному застосунку).

І ви хочете мати спосіб, щоб frontend міг автентифікуватися з backend, використовуючи **username** і **password**.

Ми можемо використати **OAuth2**, щоб реалізувати це з **FastAPI**.

Але давайте заощадимо вам час на читання повної довгої специфікації лише для того, щоб знайти ті невеликі фрагменти інформації, які вам потрібні.

Скористаймося інструментами, які надає **FastAPI**, щоб обробляти безпеку.

## Як це виглядає { #how-it-looks }

Спочатку просто використаймо код і подивімося, як він працює, а потім повернемося, щоб зрозуміти, що відбувається.

## Створіть `main.py` { #create-main-py }

Скопіюйте приклад у файл `main.py`:

{* ../../docs_src/security/tutorial001_an_py39.py *}

## Запустіть { #run-it }

/// info | Інформація

Пакет <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a> автоматично встановлюється разом із **FastAPI**, коли ви виконуєте команду `pip install "fastapi[standard]"`.

Однак, якщо ви використовуєте команду `pip install fastapi`, пакет `python-multipart` типово не включається.

Щоб встановити його вручну, переконайтеся, що ви створили [віртуальне середовище](../../virtual-environments.md){.internal-link target=_blank}, активували його, а потім встановіть пакет командою:

```console
$ pip install python-multipart
```

Це тому, що **OAuth2** використовує «form data» для надсилання `username` і `password`.

///

Запустіть приклад командою:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

## Перевірте { #check-it }

Перейдіть до інтерактивної документації за адресою: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ви побачите щось на кшталт цього:

<img src="/img/tutorial/security/image01.png">

/// check | Кнопка Authorize

У вас уже є блискуча нова кнопка «Authorize».

І ваша *операція шляху* має маленький замок у правому верхньому куті, на який можна натиснути.

///

А якщо ви натиснете її, ви побачите невелику форму авторизації, де можна ввести `username` і `password` (та інші необов’язкові поля):

<img src="/img/tutorial/security/image02.png">

/// note | Примітка

Неважливо, що ви введете у формі — наразі це ще не працюватиме. Але ми до цього дійдемо.

///

Звісно, це не frontend для кінцевих користувачів, але це чудовий автоматичний інструмент, щоб інтерактивно документувати весь ваш API.

Ним може користуватися команда frontend (це також можете бути ви самі).

Ним можуть користуватися сторонні застосунки та системи.

І ним також можете користуватися ви самі, щоб налагоджувати, перевіряти й тестувати той самий застосунок.

## Flow `password` { #the-password-flow }

Тепер повернімося трохи назад і розберімося, що це все таке.

«Flow» `password` — це один зі способів («flows»), визначених в OAuth2, для обробки безпеки та автентифікації.

OAuth2 спроєктовано так, щоб backend або API могли бути незалежними від сервера, який автентифікує користувача.

Але в цьому випадку той самий застосунок **FastAPI** оброблятиме і API, і автентифікацію.

Тож розгляньмо це з такого спрощеного погляду:

* Користувач вводить `username` і `password` у frontend та натискає `Enter`.
* Frontend (що працює в браузері користувача) надсилає ці `username` і `password` на конкретний URL у нашому API (оголошений як `tokenUrl="token"`).
* API перевіряє `username` і `password` та відповідає «token» (ми ще нічого з цього не реалізували).
    * «Token» — це просто рядок з певним вмістом, який ми зможемо використати пізніше, щоб перевірити цього користувача.
    * Зазвичай token налаштовано так, щоб він ставав недійсним після певного часу.
        * Тож користувачу доведеться знову увійти через деякий час.
        * І якщо token буде вкрадено, ризик менший. Це не як постійний ключ, який працюватиме вічно (у більшості випадків).
* Frontend тимчасово десь зберігає token.
* Користувач у frontend клікає, щоб перейти до іншого розділу вебзастосунку.
* Frontend потрібно отримати ще дані з API.
    * Але для цього конкретного endpoint потрібна автентифікація.
    * Тож, щоб автентифікуватися з нашим API, він надсилає заголовок `Authorization` зі значенням `Bearer ` плюс token.
    * Якщо token містить `foobar`, то вміст заголовка `Authorization` буде: `Bearer foobar`.

## `OAuth2PasswordBearer` у **FastAPI** { #fastapis-oauth2passwordbearer }

**FastAPI** надає кілька інструментів на різних рівнях абстракції для реалізації цих можливостей безпеки.

У цьому прикладі ми використаємо **OAuth2** з flow **Password**, застосовуючи **Bearer** token. Для цього використаємо клас `OAuth2PasswordBearer`.

/// info | Інформація

Bearer token — не єдиний варіант.

Але для нашого випадку це найкращий варіант.

І він може бути найкращим для більшості випадків, якщо тільки ви не експерт з OAuth2 і точно не знаєте, чому існує інший варіант, який краще підходить вашим потребам.

У такому разі **FastAPI** також надає вам інструменти, щоб це реалізувати.

///

Коли ми створюємо екземпляр класу `OAuth2PasswordBearer`, ми передаємо параметр `tokenUrl`. Цей параметр містить URL, який клієнт (frontend, що працює в браузері користувача) використовуватиме, щоб надіслати `username` і `password` та отримати token.

{* ../../docs_src/security/tutorial001_an_py39.py hl[8] *}

/// tip | Порада

Тут `tokenUrl="token"` посилається на відносний URL `token`, який ми ще не створили. Оскільки це відносний URL, він еквівалентний `./token`.

Тому що ми використовуємо відносний URL, якщо ваш API розміщено за адресою `https://example.com/`, тоді це посилатиметься на `https://example.com/token`. Але якщо ваш API розміщено за адресою `https://example.com/api/v1/`, тоді це посилатиметься на `https://example.com/api/v1/token`.

Використання відносного URL важливе, щоб ваш застосунок продовжував працювати навіть у складніших сценаріях, як-от [Behind a Proxy](../../advanced/behind-a-proxy.md){.internal-link target=_blank}.

///

Цей параметр не створює той endpoint / *операцію шляху*, але оголошує, що URL `/token` буде тим, який клієнт має використовувати для отримання token. Ця інформація використовується в OpenAPI, а потім — в інтерактивних системах документації API.

Незабаром ми також створимо реальну операцію шляху.

/// info | Інформація

Якщо ви дуже суворий «Pythonista», вам може не подобатися стиль імені параметра `tokenUrl` замість `token_url`.

Це тому, що тут використано те саме ім’я, що й у специфікації OpenAPI. Тож якщо вам потрібно буде дослідити більше про будь-яку з цих security scheme, ви зможете просто скопіювати й вставити це, щоб знайти більше інформації.

///

Змінна `oauth2_scheme` — це екземпляр `OAuth2PasswordBearer`, але це також «callable».

Її можна викликати так:

```Python
oauth2_scheme(some, parameters)
```

Отже, її можна використовувати з `Depends`.

### Використайте це { #use-it }

Тепер ви можете передати `oauth2_scheme` у залежність через `Depends`.

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Ця залежність надасть `str`, який буде призначено параметру `token` *функції операції шляху*.

**FastAPI** знатиме, що цю залежність можна використати для визначення «security scheme» в схемі OpenAPI (і в автоматичній документації API).

/// info | Технічні деталі

**FastAPI** знатиме, що може використати клас `OAuth2PasswordBearer` (оголошений у залежності) для визначення security scheme в OpenAPI, тому що він успадковується від `fastapi.security.oauth2.OAuth2`, який, своєю чергою, успадковується від `fastapi.security.base.SecurityBase`.

Усі утиліти безпеки, які інтегруються з OpenAPI (і з автоматичною документацією API), успадковуються від `SecurityBase` — саме так **FastAPI** знає, як інтегрувати їх в OpenAPI.

///

## Що це робить { #what-it-does }

Воно знайде в запиті заголовок `Authorization`, перевірить, чи має значення вигляд `Bearer ` плюс якийсь token, і поверне token як `str`.

Якщо заголовка `Authorization` немає, або значення не містить token з `Bearer `, воно одразу відповість помилкою зі статус-кодом 401 (`UNAUTHORIZED`).

Вам навіть не потрібно перевіряти, чи існує token, щоб повернути помилку. Ви можете бути впевнені, що якщо вашу функцію виконано, у цьому token буде `str`.

Ви вже можете спробувати це в інтерактивній документації:

<img src="/img/tutorial/security/image03.png">

Ми ще не перевіряємо валідність token, але це вже початок.

## Підсумок { #recap }

Отже, лише за 3 або 4 додаткові рядки ви вже маєте примітивну форму безпеки.
