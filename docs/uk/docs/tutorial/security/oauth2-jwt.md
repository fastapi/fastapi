# OAuth2 із паролем (і хешуванням), Bearer з JWT-токенами { #oauth2-with-password-and-hashing-bearer-with-jwt-tokens }

Тепер, коли в нас є весь security flow, зробімо застосунок справді безпечним, використовуючи токени <abbr title="JSON Web Tokens">JWT</abbr> і безпечне хешування паролів.

Цей код — те, що ви реально можете використати у своєму застосунку, зберігати хеші паролів у вашій базі даних тощо.

Ми почнемо з місця, на якому зупинилися в попередньому розділі, і будемо поступово його розширювати.

## Про JWT { #about-jwt }

JWT означає «JSON Web Tokens».

Це стандарт для кодування JSON-об’єкта в довгий щільний рядок без пробілів. Він виглядає так:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Він не зашифрований, тож будь-хто може відновити інформацію з його вмісту.

Але він підписаний. Тож коли ви отримуєте токен, який ви ж і видали, ви можете перевірити, що це справді ваш токен.

Так ви можете створити токен зі строком дії, скажімо, 1 тиждень. А потім, коли користувач повертається наступного дня з токеном, ви знаєте, що він усе ще залогінений у вашій системі.

Після тижня токен протермінується, і користувач не буде авторизований — доведеться знову увійти, щоб отримати новий токен. І якщо користувач (або третя сторона) спробує змінити токен, щоб змінити термін дії, ви зможете це виявити, бо підписи не збігатимуться.

Якщо ви хочете погратися з JWT-токенами й подивитися, як вони працюють, перегляньте <a href="https://jwt.io/" class="external-link" target="_blank">https://jwt.io</a>.

## Встановлення `PyJWT` { #install-pyjwt }

Нам потрібно встановити `PyJWT`, щоб генерувати й перевіряти JWT-токени в Python.

Переконайтеся, що ви створили [віртуальне середовище](../../virtual-environments.md){.internal-link target=_blank}, активували його, а потім встановили `pyjwt`:

<div class="termy">

```console
$ pip install pyjwt

---> 100%
```

</div>

/// info | Інформація

Якщо ви плануєте використовувати алгоритми цифрового підпису на кшталт RSA або ECDSA, вам слід встановити залежність бібліотеки cryptography: `pyjwt[crypto]`.

Детальніше про це можна прочитати в <a href="https://pyjwt.readthedocs.io/en/latest/installation.html" class="external-link" target="_blank">документації зі встановлення PyJWT</a>.

///

## Хешування пароля { #password-hashing }

«Хешування» означає перетворення певного вмісту (у цьому випадку — пароля) на послідовність байтів (просто рядок), яка виглядає як нісенітниця.

Щоразу, коли ви передаєте точно той самий вміст (точно той самий пароль), ви отримуєте точно ту саму «нісенітницю».

Але перетворити «нісенітницю» назад у пароль неможливо.

### Навіщо хешувати паролі { #why-use-password-hashing }

Якщо вашу базу даних украдуть, зловмисник не отримає відкриті паролі користувачів (plaintext), лише хеші.

Тож він не зможе спробувати використати цей пароль в іншій системі (а багато користувачів використовують один і той самий пароль всюди, і це було б небезпечно).

## Встановлення `pwdlib` { #install-pwdlib }

pwdlib — чудовий Python-пакет для роботи з хешами паролів.

Він підтримує багато безпечних алгоритмів хешування та утиліт для роботи з ними.

Рекомендований алгоритм — «Argon2».

Переконайтеся, що ви створили [віртуальне середовище](../../virtual-environments.md){.internal-link target=_blank}, активували його, а потім встановили pwdlib з Argon2:

<div class="termy">

```console
$ pip install "pwdlib[argon2]"

---> 100%
```

</div>

/// tip | Порада

З `pwdlib` ви навіть можете налаштувати його так, щоб він умів читати паролі, створені **Django**, security-плагіном для **Flask** чи багатьма іншими.

Тож ви зможете, наприклад, спільно використовувати одні й ті самі дані з Django-застосунку в базі даних із FastAPI-застосунком. Або поступово мігрувати Django-застосунок, використовуючи ту саму базу даних.

І ваші користувачі зможуть входити як із вашого Django-застосунку, так і з вашого застосунку **FastAPI** — одночасно.

///

## Хешування та перевірка паролів { #hash-and-verify-the-passwords }

Імпортуйте інструменти, які нам потрібні, з `pwdlib`.

Створіть екземпляр PasswordHash із рекомендованими налаштуваннями — він використовуватиметься для хешування та перевірки паролів.

/// tip | Порада

pwdlib також підтримує алгоритм хешування bcrypt, але не включає legacy-алгоритми — для роботи із застарілими хешами рекомендується використовувати бібліотеку passlib.

Наприклад, ви можете використати її, щоб читати й перевіряти паролі, згенеровані іншою системою (як-от Django), але хешувати всі нові паролі іншим алгоритмом, як-от Argon2 або Bcrypt.

І бути сумісними з усіма ними одночасно.

///

Створіть утилітну функцію для хешування пароля, що надходить від користувача.

І ще одну утиліту, щоб перевіряти, чи збігається отриманий пароль із збереженим хешем.

І ще одну — щоб автентифікувати й повертати користувача.

{* ../../docs_src/security/tutorial004_an_py310.py hl[8,49,56:57,60:61,70:76] *}

/// note | Примітка

Якщо ви перевірите нову (фейкову) базу даних `fake_users_db`, ви побачите, як тепер виглядає хешований пароль: `"$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc"`.

///

## Обробка JWT-токенів { #handle-jwt-tokens }

Імпортуйте встановлені модулі.

Створіть випадковий секретний ключ, який буде використано для підпису JWT-токенів.

Щоб згенерувати безпечний випадковий секретний ключ, використайте команду:

<div class="termy">

```console
$ openssl rand -hex 32

09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
```

</div>

І скопіюйте вивід у змінну `SECRET_KEY` (не використовуйте той, що в прикладі).

Створіть змінну `ALGORITHM` з алгоритмом, що використовується для підпису JWT-токена, і встановіть її в `"HS256"`.

Створіть змінну для часу дії токена.

Визначте Pydantic Model, який буде використано в endpoint токена для відповіді.

Створіть утилітну функцію для генерації нового access token.

{* ../../docs_src/security/tutorial004_an_py310.py hl[4,7,13:15,29:31,79:87] *}

## Оновлення залежностей { #update-the-dependencies }

Оновіть `get_current_user`, щоб отримувати той самий токен, що й раніше, але цього разу — використовуючи JWT-токени.

Розкодуйте отриманий токен, перевірте його та поверніть поточного користувача.

Якщо токен недійсний — одразу поверніть HTTP-помилку.

{* ../../docs_src/security/tutorial004_an_py310.py hl[90:107] *}

## Оновлення *операції шляху* `/token` { #update-the-token-path-operation }

Створіть `timedelta` із часом дії токена.

Створіть реальний JWT access token і поверніть його.

{* ../../docs_src/security/tutorial004_an_py310.py hl[118:133] *}

### Технічні деталі про «subject» JWT `sub` { #technical-details-about-the-jwt-subject-sub }

Специфікація JWT каже, що існує ключ `sub`, із темою (subject) токена.

Використовувати його необов’язково, але саме туди ви зазвичай поміщаєте ідентифікацію користувача, тож ми використовуємо його тут.

JWT можна використовувати й для інших речей, окрім ідентифікації користувача та надання йому можливості виконувати операції напряму на вашому API.

Наприклад, ви можете ідентифікувати «автомобіль» або «допис у блозі».

Тоді ви можете додати дозволи щодо цієї сутності, наприклад «drive» (для автомобіля) або «edit» (для блогу).

А потім ви можете видати цей JWT-токен користувачу (або боту), і він зможе використовувати його, щоб виконувати ці дії (керувати автомобілем або редагувати допис) навіть без акаунта — лише з JWT-токеном, який ваше API згенерувало для цього.

Використовуючи ці ідеї, JWT можна застосовувати в набагато більш складних сценаріях.

У таких випадках кілька з цих сутностей можуть мати однаковий ID, скажімо `foo` (користувач `foo`, автомобіль `foo` і допис `foo`).

Тож, щоб уникнути колізій ID, під час створення JWT-токена для користувача ви можете додати префікс до значення ключа `sub`, наприклад `username:`. Тож у цьому прикладі значення `sub` могло би бути: `username:johndoe`.

Важливо пам’ятати: ключ `sub` має мати унікальний ідентифікатор у межах усього застосунку, і він має бути рядком.

## Перевірка { #check-it }

Запустіть сервер і перейдіть до документації: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ви побачите інтерфейс користувача приблизно такий:

<img src="/img/tutorial/security/image07.png">

Авторизуйте застосунок так само, як і раніше.

Використовуючи облікові дані:

Ім’я користувача: `johndoe`
Пароль: `secret`

/// check | Перевірка

Зверніть увагу, що в коді ніде немає відкритого пароля "`secret`" — у нас є лише його хешована версія.

///

<img src="/img/tutorial/security/image08.png">

Викличте endpoint `/users/me/`, ви отримаєте відповідь:

```JSON
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false
}
```

<img src="/img/tutorial/security/image09.png">

Якщо ви відкриєте інструменти розробника, ви зможете побачити, що надіслані дані містять лише токен; пароль надсилається лише в першому запиті, щоб автентифікувати користувача й отримати access token, але не надсилається після цього:

<img src="/img/tutorial/security/image10.png">

/// note | Примітка

Зверніть увагу на заголовок `Authorization`, зі значенням, яке починається з `Bearer `.

///

## Розширене використання зі `scopes` { #advanced-usage-with-scopes }

OAuth2 має поняття «scopes».

Ви можете використати їх, щоб додати до JWT-токена конкретний набір дозволів.

Потім ви можете надати цей токен користувачу напряму або третій стороні, щоб взаємодіяти з вашим API з певним набором обмежень.

Пізніше ви дізнаєтеся, як їх використовувати та як вони інтегруються у **FastAPI**, у **Розширеному посібнику користувача**.

## Підсумок { #recap }

На основі того, що ви побачили до цього моменту, ви можете налаштувати безпечний застосунок **FastAPI**, використовуючи стандарти на кшталт OAuth2 і JWT.

Майже в будь-якому framework робота з безпекою досить швидко стає складною темою.

Багато пакетів, що значно її спрощують, змушені робити багато компромісів щодо моделі даних, бази даних і доступних можливостей. А деякі пакети, що надмірно спрощують речі, насправді мають приховані вразливості.

---

**FastAPI** не йде на компроміси з жодною базою даних, моделлю даних чи інструментом.

Він дає вам повну гнучкість, щоб обрати те, що найкраще підходить вашому проєкту.

І ви можете напряму використовувати багато добре підтримуваних і широко застосовуваних пакетів, як-от `pwdlib` і `PyJWT`, бо **FastAPI** не потребує жодних складних механізмів для інтеграції зовнішніх пакетів.

Водночас він надає вам інструменти, щоб максимально спростити процес без втрати гнучкості, надійності чи безпеки.

І ви можете використовувати та реалізовувати безпечні стандартні протоколи, як-от OAuth2, відносно простим способом.

У **Розширеному посібнику користувача** ви можете дізнатися більше про те, як використовувати OAuth2 «scopes» для більш тонко налаштованої системи дозволів, дотримуючись цих самих стандартів. OAuth2 зі scopes — це механізм, який використовують багато великих провайдерів автентифікації, як-от Facebook, Google, GitHub, Microsoft, X (Twitter) тощо, щоб авторизувати сторонні застосунки для взаємодії з їхніми API від імені користувачів.
